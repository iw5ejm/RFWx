
images/MicroDigi.elf:     formato del file elf32-avr

Sezioni:
Ind Nome          Dimens    VMA       LMA       Pos file  Allin
  0 .data         0000003c  00800100  000023d8  0000246c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000023d8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000063b  0080013c  0080013c  000024a8  2**0
                  ALLOC
  3 .stab         000042fc  00000000  00000000  000024a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000263c  00000000  00000000  000067a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00008de0  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00008df4  2**2
                  CONTENTS, READONLY

Disassemblamento della sezione .text:

00000000 <__vectors>:
       0:	0c 94 be 01 	jmp	0x37c	; 0x37c <__ctors_end>
       4:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
       8:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
       c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      10:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      14:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      18:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      1c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      20:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      24:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      28:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      2c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      30:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      34:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      38:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      3c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      40:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      44:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      48:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      4c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      50:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      54:	0c 94 f8 06 	jmp	0xdf0	; 0xdf0 <__vector_21>
      58:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      5c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      60:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      64:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>

00000068 <__trampolines_end>:
      68:	80 81       	ld	r24, Z
      6a:	83 84       	ldd	r8, Z+11	; 0x0b
      6c:	86 87       	std	Z+14, r24	; 0x0e
      6e:	89 8a       	std	Y+17, r8	; 0x11
      70:	8c 8e       	std	Y+28, r8	; 0x1c
      72:	8f 91       	pop	r24
      74:	92 94       	swap	r9
      76:	95 97       	sbiw	r26, 0x25	; 37
      78:	98 9a       	sbi	0x13, 0	; 19
      7a:	9b 9d       	mul	r25, r11
      7c:	9e a0       	ldd	r9, Y+38	; 0x26
      7e:	a2 a3       	std	Z+34, r26	; 0x22
      80:	a5 a6       	std	Z+45, r10	; 0x2d
      82:	a7 a9       	ldd	r26, Z+55	; 0x37
      84:	aa ac       	ldd	r10, Y+58	; 0x3a
      86:	ad af       	std	Y+61, r26	; 0x3d
      88:	b0 b2       	in	r11, 0x10	; 16
      8a:	b3 b5       	in	r27, 0x23	; 35
      8c:	b6 b7       	in	r27, 0x36	; 54
      8e:	b9 ba       	out	0x19, r11	; 25
      90:	bc bd       	out	0x2c, r27	; 44
      92:	be c0       	rjmp	.+380    	; 0x210 <crc_ccit_table+0x128>
      94:	c1 c2       	rjmp	.+1410   	; 0x618 <afsk_getchar+0x2a>
      96:	c4 c5       	rjmp	.+2952   	; 0xc20 <AFSK_adc_isr+0x1f2>
      98:	c6 c8       	rjmp	.-3700   	; 0xfffff226 <__eeprom_end+0xff7ef226>
      9a:	c9 ca       	rjmp	.-2670   	; 0xfffff62e <__eeprom_end+0xff7ef62e>
      9c:	cb cd       	rjmp	.-1130   	; 0xfffffc34 <__eeprom_end+0xff7efc34>
      9e:	ce cf       	rjmp	.-100    	; 0x3c <__zero_reg__+0x3b>
      a0:	d0 d2       	rcall	.+1440   	; 0x642 <afsk_getchar+0x54>
      a2:	d3 d4       	rcall	.+2470   	; 0xa4a <AFSK_adc_isr+0x1c>
      a4:	d5 d6       	rcall	.+3498   	; 0xe50 <__vector_21+0x60>
      a6:	d7 d9       	rcall	.-3154   	; 0xfffff456 <__eeprom_end+0xff7ef456>
      a8:	da db       	rcall	.-2124   	; 0xfffff85e <__eeprom_end+0xff7ef85e>
      aa:	dc dd       	rcall	.-1096   	; 0xfffffc64 <__eeprom_end+0xff7efc64>
      ac:	de df       	rcall	.-68     	; 0x6a <__trampolines_end+0x2>
      ae:	e0 e1       	ldi	r30, 0x10	; 16
      b0:	e2 e3       	ldi	r30, 0x32	; 50
      b2:	e4 e5       	ldi	r30, 0x54	; 84
      b4:	e6 e7       	ldi	r30, 0x76	; 118
      b6:	e8 e9       	ldi	r30, 0x98	; 152
      b8:	ea ea       	ldi	r30, 0xAA	; 170
      ba:	eb ec       	ldi	r30, 0xCB	; 203
      bc:	ed ee       	ldi	r30, 0xED	; 237
      be:	ee ef       	ldi	r30, 0xFE	; 254
      c0:	f0 f1       	brcs	.+124    	; 0x13e <crc_ccit_table+0x56>
      c2:	f1 f2       	breq	.-68     	; 0x80 <__trampolines_end+0x18>
      c4:	f3 f3       	brvs	.-4      	; 0xc2 <__trampolines_end+0x5a>
      c6:	f4 f5       	brge	.+124    	; 0x144 <crc_ccit_table+0x5c>
      c8:	f5 f6       	brhc	.-68     	; 0x86 <__trampolines_end+0x1e>
      ca:	f6 f7       	brtc	.-4      	; 0xc8 <__trampolines_end+0x60>
      cc:	f8 f8       	.word	0xf8f8	; ????
      ce:	f9 f9       	.word	0xf9f9	; ????
      d0:	fa fa       	.word	0xfafa	; ????
      d2:	fa fb       	.word	0xfbfa	; ????
      d4:	fb fc       	.word	0xfcfb	; ????
      d6:	fc fc       	.word	0xfcfc	; ????
      d8:	fd fd       	.word	0xfdfd	; ????
      da:	fd fd       	.word	0xfdfd	; ????
      dc:	fe fe       	.word	0xfefe	; ????
      de:	fe fe       	.word	0xfefe	; ????
      e0:	fe ff       	.word	0xfffe	; ????
      e2:	ff ff       	.word	0xffff	; ????
      e4:	ff ff       	.word	0xffff	; ????
      e6:	ff ff       	.word	0xffff	; ????

000000e8 <crc_ccit_table>:
      e8:	00 00 89 11 12 23 9b 32 24 46 ad 57 36 65 bf 74     .....#.2$F.W6e.t
      f8:	48 8c c1 9d 5a af d3 be 6c ca e5 db 7e e9 f7 f8     H...Z...l...~...
     108:	81 10 08 01 93 33 1a 22 a5 56 2c 47 b7 75 3e 64     .....3.".V,G.u>d
     118:	c9 9c 40 8d db bf 52 ae ed da 64 cb ff f9 76 e8     ..@...R...d...v.
     128:	02 21 8b 30 10 02 99 13 26 67 af 76 34 44 bd 55     .!.0....&g.v4D.U
     138:	4a ad c3 bc 58 8e d1 9f 6e eb e7 fa 7c c8 f5 d9     J...X...n...|...
     148:	83 31 0a 20 91 12 18 03 a7 77 2e 66 b5 54 3c 45     .1. .....w.f.T<E
     158:	cb bd 42 ac d9 9e 50 8f ef fb 66 ea fd d8 74 c9     ..B...P...f...t.
     168:	04 42 8d 53 16 61 9f 70 20 04 a9 15 32 27 bb 36     .B.S.a.p ...2'.6
     178:	4c ce c5 df 5e ed d7 fc 68 88 e1 99 7a ab f3 ba     L...^...h...z...
     188:	85 52 0c 43 97 71 1e 60 a1 14 28 05 b3 37 3a 26     .R.C.q.`..(..7:&
     198:	cd de 44 cf df fd 56 ec e9 98 60 89 fb bb 72 aa     ..D...V...`...r.
     1a8:	06 63 8f 72 14 40 9d 51 22 25 ab 34 30 06 b9 17     .c.r.@.Q"%.40...
     1b8:	4e ef c7 fe 5c cc d5 dd 6a a9 e3 b8 78 8a f1 9b     N...\...j...x...
     1c8:	87 73 0e 62 95 50 1c 41 a3 35 2a 24 b1 16 38 07     .s.b.P.A.5*$..8.
     1d8:	cf ff 46 ee dd dc 54 cd eb b9 62 a8 f9 9a 70 8b     ..F...T...b...p.
     1e8:	08 84 81 95 1a a7 93 b6 2c c2 a5 d3 3e e1 b7 f0     ........,...>...
     1f8:	40 08 c9 19 52 2b db 3a 64 4e ed 5f 76 6d ff 7c     @...R+.:dN._vm.|
     208:	89 94 00 85 9b b7 12 a6 ad d2 24 c3 bf f1 36 e0     ..........$...6.
     218:	c1 18 48 09 d3 3b 5a 2a e5 5e 6c 4f f7 7d 7e 6c     ..H..;Z*.^lO.}~l
     228:	0a a5 83 b4 18 86 91 97 2e e3 a7 f2 3c c0 b5 d1     ............<...
     238:	42 29 cb 38 50 0a d9 1b 66 6f ef 7e 74 4c fd 5d     B).8P...fo.~tL.]
     248:	8b b5 02 a4 99 96 10 87 af f3 26 e2 bd d0 34 c1     ..........&...4.
     258:	c3 39 4a 28 d1 1a 58 0b e7 7f 6e 6e f5 5c 7c 4d     .9J(..X...nn.\|M
     268:	0c c6 85 d7 1e e5 97 f4 28 80 a1 91 3a a3 b3 b2     ........(...:...
     278:	44 4a cd 5b 56 69 df 78 60 0c e9 1d 72 2f fb 3e     DJ.[Vi.x`...r/.>
     288:	8d d6 04 c7 9f f5 16 e4 a9 90 20 81 bb b3 32 a2     .......... ...2.
     298:	c5 5a 4c 4b d7 79 5e 68 e1 1c 68 0d f3 3f 7a 2e     .ZLK.y^h..h..?z.
     2a8:	0e e7 87 f6 1c c4 95 d5 2a a1 a3 b0 38 82 b1 93     ........*...8...
     2b8:	46 6b cf 7a 54 48 dd 59 62 2d eb 3c 70 0e f9 1f     Fk.zTH.Yb-.<p...
     2c8:	8f f7 06 e6 9d d4 14 c5 ab b1 22 a0 b9 92 30 83     .........."...0.
     2d8:	c7 7b 4e 6a d5 58 5c 49 e3 3d 6a 2c f1 1e 78 0f     .{Nj.X\I.=j,..x.

000002e8 <__c.2473>:
     2e8:	44 75 70 6c 69 63 61 74 65 20 64 65 74 65 63 74     Duplicate detect
     2f8:	65 64 2c 20 64 72 6f 70 70 69 6e 67 20 70 61 63     ed, dropping pac
     308:	6b 65 74 0a 0a 00                                   ket...

0000030e <__c.2471>:
     30e:	0a 00                                               ..

00000310 <__c.2443>:
     310:	0a 4e 6f 74 20 64 69 67 69 70 65 61 74 69 6e 67     .Not digipeating
     320:	0a 00                                               ..

00000322 <__c.2438>:
     322:	2c 25 2e 36 73 2d 25 64 00                          ,%.6s-%d.

0000032b <__c.2436>:
     32b:	2c 25 2e 36 73 2d 25 64 2a 00                       ,%.6s-%d*.

00000335 <__c.2433>:
     335:	0a 00                                               ..

00000337 <__c.2428>:
     337:	5b 25 2e 36 73 2d 25 64 5d 20 00                    [%.6s-%d] .

00000342 <__c.2426>:
     342:	5b 25 2e 36 73 2d 25 64 2a 5d 20 00                 [%.6s-%d*] .

0000034e <__c.2423>:
     34e:	0a 52 58 64 20 50 61 74 68 20 28 25 64 29 3a 20     .RXd Path (%d): 
	...

0000035f <__c.2421>:
     35f:	44 53 54 5b 25 2e 36 73 2d 25 64 5d 20 00           DST[%.6s-%d] .

0000036d <__c.2419>:
     36d:	53 52 43 5b 25 2e 36 73 2d 25 64 5d 20 00 00        SRC[%.6s-%d] ..

0000037c <__ctors_end>:
     37c:	11 24       	eor	r1, r1
     37e:	1f be       	out	0x3f, r1	; 63
     380:	cf ef       	ldi	r28, 0xFF	; 255
     382:	d8 e0       	ldi	r29, 0x08	; 8
     384:	de bf       	out	0x3e, r29	; 62
     386:	cd bf       	out	0x3d, r28	; 61

00000388 <__do_copy_data>:
     388:	11 e0       	ldi	r17, 0x01	; 1
     38a:	a0 e0       	ldi	r26, 0x00	; 0
     38c:	b1 e0       	ldi	r27, 0x01	; 1
     38e:	e8 ed       	ldi	r30, 0xD8	; 216
     390:	f3 e2       	ldi	r31, 0x23	; 35
     392:	02 c0       	rjmp	.+4      	; 0x398 <__do_copy_data+0x10>
     394:	05 90       	lpm	r0, Z+
     396:	0d 92       	st	X+, r0
     398:	ac 33       	cpi	r26, 0x3C	; 60
     39a:	b1 07       	cpc	r27, r17
     39c:	d9 f7       	brne	.-10     	; 0x394 <__do_copy_data+0xc>

0000039e <__do_clear_bss>:
     39e:	27 e0       	ldi	r18, 0x07	; 7
     3a0:	ac e3       	ldi	r26, 0x3C	; 60
     3a2:	b1 e0       	ldi	r27, 0x01	; 1
     3a4:	01 c0       	rjmp	.+2      	; 0x3a8 <.do_clear_bss_start>

000003a6 <.do_clear_bss_loop>:
     3a6:	1d 92       	st	X+, r1

000003a8 <.do_clear_bss_start>:
     3a8:	a7 37       	cpi	r26, 0x77	; 119
     3aa:	b2 07       	cpc	r27, r18
     3ac:	e1 f7       	brne	.-8      	; 0x3a6 <.do_clear_bss_loop>
     3ae:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <main>
     3b2:	0c 94 ea 11 	jmp	0x23d4	; 0x23d4 <_exit>

000003b6 <__bad_interrupt>:
     3b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003ba <ax25_callback>:

unsigned long custom_preamble = CONFIG_AFSK_PREAMBLE_LEN;
unsigned long custom_tail = CONFIG_AFSK_TRAILER_LEN;

static void ax25_callback(struct AX25Ctx *ctx) {
    digipeater_messageCallback(ctx);
     3ba:	0c 94 98 0d 	jmp	0x1b30	; 0x1b30 <digipeater_messageCallback>

000003be <init>:
}

void init(void) {
    sei();
     3be:	78 94       	sei

    AFSK_init(&modem);
     3c0:	81 e4       	ldi	r24, 0x41	; 65
     3c2:	91 e0       	ldi	r25, 0x01	; 1
     3c4:	0e 94 54 03 	call	0x6a8	; 0x6a8 <AFSK_init>
    ax25_init(&AX25, &modem.fd, ax25_callback);
     3c8:	4d ed       	ldi	r20, 0xDD	; 221
     3ca:	51 e0       	ldi	r21, 0x01	; 1
     3cc:	61 e4       	ldi	r22, 0x41	; 65
     3ce:	71 e0       	ldi	r23, 0x01	; 1
     3d0:	85 e6       	ldi	r24, 0x65	; 101
     3d2:	92 e0       	ldi	r25, 0x02	; 2
     3d4:	0e 94 91 07 	call	0xf22	; 0xf22 <ax25_init>
    digipeater_init(&AX25, &modem, &serial);
     3d8:	48 e1       	ldi	r20, 0x18	; 24
     3da:	52 e0       	ldi	r21, 0x02	; 2
     3dc:	61 e4       	ldi	r22, 0x41	; 65
     3de:	71 e0       	ldi	r23, 0x01	; 1
     3e0:	85 e6       	ldi	r24, 0x65	; 101
     3e2:	92 e0       	ldi	r25, 0x02	; 2
     3e4:	0e 94 ed 08 	call	0x11da	; 0x11da <digipeater_init>

    serial_init(&serial);
     3e8:	88 e1       	ldi	r24, 0x18	; 24
     3ea:	92 e0       	ldi	r25, 0x02	; 2
     3ec:	0e 94 0f 02 	call	0x41e	; 0x41e <serial_init>
    stdout = &serial.uart0;
     3f0:	e1 e7       	ldi	r30, 0x71	; 113
     3f2:	f7 e0       	ldi	r31, 0x07	; 7
     3f4:	88 e1       	ldi	r24, 0x18	; 24
     3f6:	92 e0       	ldi	r25, 0x02	; 2
     3f8:	93 83       	std	Z+3, r25	; 0x03
     3fa:	82 83       	std	Z+2, r24	; 0x02
    stdin  = &serial.uart0;
     3fc:	91 83       	std	Z+1, r25	; 0x01
     3fe:	80 83       	st	Z, r24
     400:	08 95       	ret

00000402 <uart0_putchar>:
    return false;
}


void uart0_putchar(char c) {
    loop_until_bit_is_set(UCSR0A, UDRE0);
     402:	90 91 c0 00 	lds	r25, 0x00C0
     406:	95 ff       	sbrs	r25, 5
     408:	fc cf       	rjmp	.-8      	; 0x402 <uart0_putchar>
    UDR0 = c;
     40a:	80 93 c6 00 	sts	0x00C6, r24
     40e:	08 95       	ret

00000410 <uart0_getchar>:
}

char uart0_getchar(void) {
    loop_until_bit_is_set(UCSR0A, RXC0);
     410:	80 91 c0 00 	lds	r24, 0x00C0
     414:	87 ff       	sbrs	r24, 7
     416:	fc cf       	rjmp	.-8      	; 0x410 <uart0_getchar>
    return UDR0;
     418:	80 91 c6 00 	lds	r24, 0x00C6
}
     41c:	08 95       	ret

0000041e <serial_init>:
#include "Serial.h"
#include <util/setbaud.h>
#include <stdio.h>
#include <string.h>

void serial_init(Serial *serial) {
     41e:	cf 93       	push	r28
     420:	df 93       	push	r29
     422:	cd b7       	in	r28, 0x3d	; 61
     424:	de b7       	in	r29, 0x3e	; 62
     426:	2e 97       	sbiw	r28, 0x0e	; 14
     428:	0f b6       	in	r0, 0x3f	; 63
     42a:	f8 94       	cli
     42c:	de bf       	out	0x3e, r29	; 62
     42e:	0f be       	out	0x3f, r0	; 63
     430:	cd bf       	out	0x3d, r28	; 61
     432:	dc 01       	movw	r26, r24
    memset(serial, 0, sizeof(*serial));
     434:	8e e0       	ldi	r24, 0x0E	; 14
     436:	fd 01       	movw	r30, r26
     438:	98 2f       	mov	r25, r24
     43a:	11 92       	st	Z+, r1
     43c:	9a 95       	dec	r25
     43e:	e9 f7       	brne	.-6      	; 0x43a <serial_init+0x1c>
    UBRR0H = UBRRH_VALUE;
     440:	10 92 c5 00 	sts	0x00C5, r1
    UBRR0L = UBRRL_VALUE;
     444:	97 e6       	ldi	r25, 0x67	; 103
     446:	90 93 c4 00 	sts	0x00C4, r25

    #if USE_2X
        UCSR0A |= _BV(U2X0);
    #else
        UCSR0A &= ~(_BV(U2X0));
     44a:	e0 ec       	ldi	r30, 0xC0	; 192
     44c:	f0 e0       	ldi	r31, 0x00	; 0
     44e:	90 81       	ld	r25, Z
     450:	9d 7f       	andi	r25, 0xFD	; 253
     452:	90 83       	st	Z, r25
    #endif

    // Set to 8-bit data, enable RX and TX
    UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
     454:	96 e0       	ldi	r25, 0x06	; 6
     456:	90 93 c2 00 	sts	0x00C2, r25
    UCSR0B = _BV(RXEN0) | _BV(TXEN0);
     45a:	98 e1       	ldi	r25, 0x18	; 24
     45c:	90 93 c1 00 	sts	0x00C1, r25

    FILE uart0_fd = FDEV_SETUP_STREAM(uart0_putchar, uart0_getchar, _FDEV_SETUP_RW);
     460:	9e 01       	movw	r18, r28
     462:	2f 5f       	subi	r18, 0xFF	; 255
     464:	3f 4f       	sbci	r19, 0xFF	; 255
     466:	f9 01       	movw	r30, r18
     468:	11 92       	st	Z+, r1
     46a:	8a 95       	dec	r24
     46c:	e9 f7       	brne	.-6      	; 0x468 <serial_init+0x4a>

    serial->uart0 = uart0_fd;
     46e:	83 e0       	ldi	r24, 0x03	; 3
     470:	8c 83       	std	Y+4, r24	; 0x04
     472:	81 e0       	ldi	r24, 0x01	; 1
     474:	92 e0       	ldi	r25, 0x02	; 2
     476:	9a 87       	std	Y+10, r25	; 0x0a
     478:	89 87       	std	Y+9, r24	; 0x09
     47a:	88 e0       	ldi	r24, 0x08	; 8
     47c:	92 e0       	ldi	r25, 0x02	; 2
     47e:	9c 87       	std	Y+12, r25	; 0x0c
     480:	8b 87       	std	Y+11, r24	; 0x0b
     482:	9e e0       	ldi	r25, 0x0E	; 14
     484:	f9 01       	movw	r30, r18
     486:	01 90       	ld	r0, Z+
     488:	0d 92       	st	X+, r0
     48a:	9a 95       	dec	r25
     48c:	e1 f7       	brne	.-8      	; 0x486 <serial_init+0x68>
}
     48e:	2e 96       	adiw	r28, 0x0e	; 14
     490:	0f b6       	in	r0, 0x3f	; 63
     492:	f8 94       	cli
     494:	de bf       	out	0x3e, r29	; 62
     496:	0f be       	out	0x3f, r0	; 63
     498:	cd bf       	out	0x3d, r28	; 61
     49a:	df 91       	pop	r29
     49c:	cf 91       	pop	r28
     49e:	08 95       	ret

000004a0 <serial_available>:

bool serial_available(uint8_t index) {
    if (index == 0) {
     4a0:	81 11       	cpse	r24, r1
     4a2:	06 c0       	rjmp	.+12     	; 0x4b0 <serial_available+0x10>
        if (UCSR0A & _BV(RXC0)) return true;
     4a4:	80 91 c0 00 	lds	r24, 0x00C0
     4a8:	88 1f       	adc	r24, r24
     4aa:	88 27       	eor	r24, r24
     4ac:	88 1f       	adc	r24, r24
     4ae:	08 95       	ret
    }
    return false;
     4b0:	80 e0       	ldi	r24, 0x00	; 0
}
     4b2:	08 95       	ret

000004b4 <uart0_getchar_nowait>:
    loop_until_bit_is_set(UCSR0A, RXC0);
    return UDR0;
}

char uart0_getchar_nowait(void) {
    if (!(UCSR0A & _BV(RXC0))) return EOF;
     4b4:	80 91 c0 00 	lds	r24, 0x00C0
     4b8:	87 ff       	sbrs	r24, 7
     4ba:	03 c0       	rjmp	.+6      	; 0x4c2 <uart0_getchar_nowait+0xe>
    return UDR0;
     4bc:	80 91 c6 00 	lds	r24, 0x00C6
     4c0:	08 95       	ret
    loop_until_bit_is_set(UCSR0A, RXC0);
    return UDR0;
}

char uart0_getchar_nowait(void) {
    if (!(UCSR0A & _BV(RXC0))) return EOF;
     4c2:	8f ef       	ldi	r24, 0xFF	; 255
    return UDR0;
     4c4:	08 95       	ret

000004c6 <afsk_putchar>:
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
      afsk->tailLength = DIV_ROUND(custom_tail * BITRATE, 8000);
    }
}

void afsk_putchar(char c) {
     4c6:	0f 93       	push	r16
     4c8:	1f 93       	push	r17
     4ca:	cf 93       	push	r28
     4cc:	df 93       	push	r29
     4ce:	18 2f       	mov	r17, r24
    AFSK_txStart(AFSK_modem);
     4d0:	c0 91 f3 03 	lds	r28, 0x03F3
     4d4:	d0 91 f4 03 	lds	r29, 0x03F4
    FILE afsk_fd = FDEV_SETUP_STREAM(afsk_putchar, afsk_getchar, _FDEV_SETUP_RW);
    afsk->fd = afsk_fd;
}

static void AFSK_txStart(Afsk *afsk) {
    if (!afsk->sending) {
     4d8:	fe 01       	movw	r30, r28
     4da:	e9 59       	subi	r30, 0x99	; 153
     4dc:	ff 4f       	sbci	r31, 0xFF	; 255
     4de:	80 81       	ld	r24, Z
     4e0:	81 11       	cpse	r24, r1
     4e2:	24 c0       	rjmp	.+72     	; 0x52c <afsk_putchar+0x66>
        afsk->phaseInc = MARK_INC;
     4e4:	80 e4       	ldi	r24, 0x40	; 64
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	9e 8f       	std	Y+30, r25	; 0x1e
     4ea:	8d 8f       	std	Y+29, r24	; 0x1d
        afsk->phaseAcc = 0;
     4ec:	1c 8e       	std	Y+28, r1	; 0x1c
     4ee:	1b 8e       	std	Y+27, r1	; 0x1b
        afsk->bitstuffCount = 0;
     4f0:	1a 8e       	std	Y+26, r1	; 0x1a
        afsk->sending = true;
     4f2:	01 e0       	ldi	r16, 0x01	; 1
     4f4:	00 83       	st	Z, r16
        LED_TX_ON();
     4f6:	29 9a       	sbi	0x05, 1	; 5
        afsk->preambleLength = DIV_ROUND(custom_preamble * BITRATE, 8000);
     4f8:	20 91 04 01 	lds	r18, 0x0104
     4fc:	30 91 05 01 	lds	r19, 0x0105
     500:	40 91 06 01 	lds	r20, 0x0106
     504:	50 91 07 01 	lds	r21, 0x0107
     508:	a0 eb       	ldi	r26, 0xB0	; 176
     50a:	b4 e0       	ldi	r27, 0x04	; 4
     50c:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <__muluhisi3>
     510:	60 56       	subi	r22, 0x60	; 96
     512:	70 4f       	sbci	r23, 0xF0	; 240
     514:	8f 4f       	sbci	r24, 0xFF	; 255
     516:	9f 4f       	sbci	r25, 0xFF	; 255
     518:	20 e4       	ldi	r18, 0x40	; 64
     51a:	3f e1       	ldi	r19, 0x1F	; 31
     51c:	40 e0       	ldi	r20, 0x00	; 0
     51e:	50 e0       	ldi	r21, 0x00	; 0
     520:	0e 94 c2 0d 	call	0x1b84	; 0x1b84 <__udivmodsi4>
     524:	3b 8b       	std	Y+19, r19	; 0x13
     526:	2a 8b       	std	Y+18, r18	; 0x12
        AFSK_DAC_IRQ_START();
     528:	00 93 3d 01 	sts	0x013D, r16
    }
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     52c:	0f b7       	in	r16, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     52e:	f8 94       	cli
      afsk->tailLength = DIV_ROUND(custom_tail * BITRATE, 8000);
     530:	20 91 00 01 	lds	r18, 0x0100
     534:	30 91 01 01 	lds	r19, 0x0101
     538:	40 91 02 01 	lds	r20, 0x0102
     53c:	50 91 03 01 	lds	r21, 0x0103
     540:	a0 eb       	ldi	r26, 0xB0	; 176
     542:	b4 e0       	ldi	r27, 0x04	; 4
     544:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <__muluhisi3>
     548:	60 56       	subi	r22, 0x60	; 96
     54a:	70 4f       	sbci	r23, 0xF0	; 240
     54c:	8f 4f       	sbci	r24, 0xFF	; 255
     54e:	9f 4f       	sbci	r25, 0xFF	; 255
     550:	20 e4       	ldi	r18, 0x40	; 64
     552:	3f e1       	ldi	r19, 0x1F	; 31
     554:	40 e0       	ldi	r20, 0x00	; 0
     556:	50 e0       	ldi	r21, 0x00	; 0
     558:	0e 94 c2 0d 	call	0x1b84	; 0x1b84 <__udivmodsi4>
     55c:	3d 8b       	std	Y+21, r19	; 0x15
     55e:	2c 8b       	std	Y+20, r18	; 0x14
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     560:	0f bf       	out	0x3f, r16	; 63
    }
}

void afsk_putchar(char c) {
    AFSK_txStart(AFSK_modem);
    while(fifo_isfull_locked(&AFSK_modem->txFifo)) { /* Wait */ }
     562:	e0 91 f3 03 	lds	r30, 0x03F3
     566:	f0 91 f4 03 	lds	r31, 0x03F4
  return result;
}

inline bool fifo_isfull_locked(const FIFOBuffer *f) {
  bool result;
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     56a:	4f b7       	in	r20, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     56c:	f8 94       	cli
inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
}

inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
     56e:	23 a1       	ldd	r18, Z+35	; 0x23
     570:	34 a1       	ldd	r19, Z+36	; 0x24
     572:	87 8d       	ldd	r24, Z+31	; 0x1f
     574:	90 a1       	ldd	r25, Z+32	; 0x20
     576:	28 17       	cp	r18, r24
     578:	39 07       	cpc	r19, r25
     57a:	39 f4       	brne	.+14     	; 0x58a <afsk_putchar+0xc4>
     57c:	25 a1       	ldd	r18, Z+37	; 0x25
     57e:	36 a1       	ldd	r19, Z+38	; 0x26
     580:	81 a1       	ldd	r24, Z+33	; 0x21
     582:	92 a1       	ldd	r25, Z+34	; 0x22
     584:	28 17       	cp	r18, r24
     586:	39 07       	cpc	r19, r25
     588:	79 f0       	breq	.+30     	; 0x5a8 <afsk_putchar+0xe2>
     58a:	65 a1       	ldd	r22, Z+37	; 0x25
     58c:	76 a1       	ldd	r23, Z+38	; 0x26
     58e:	23 a1       	ldd	r18, Z+35	; 0x23
     590:	34 a1       	ldd	r19, Z+36	; 0x24
     592:	21 50       	subi	r18, 0x01	; 1
     594:	31 09       	sbc	r19, r1
     596:	91 e0       	ldi	r25, 0x01	; 1
     598:	80 e0       	ldi	r24, 0x00	; 0
     59a:	62 17       	cp	r22, r18
     59c:	73 07       	cpc	r23, r19
     59e:	09 f0       	breq	.+2      	; 0x5a2 <afsk_putchar+0xdc>
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	29 2f       	mov	r18, r25
     5a4:	38 2f       	mov	r19, r24
     5a6:	02 c0       	rjmp	.+4      	; 0x5ac <afsk_putchar+0xe6>
     5a8:	21 e0       	ldi	r18, 0x01	; 1
     5aa:	30 e0       	ldi	r19, 0x00	; 0
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     5ac:	4f bf       	out	0x3f, r20	; 63
     5ae:	23 2b       	or	r18, r19
     5b0:	c1 f6       	brne	.-80     	; 0x562 <afsk_putchar+0x9c>
    fifo_push_locked(&AFSK_modem->txFifo, c);
     5b2:	e0 91 f3 03 	lds	r30, 0x03F3
     5b6:	f0 91 f4 03 	lds	r31, 0x03F4
  }
  return result;
}

inline void fifo_push_locked(FIFOBuffer *f, unsigned char c) {
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     5ba:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     5bc:	f8 94       	cli
inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     5be:	a5 a1       	ldd	r26, Z+37	; 0x25
     5c0:	b6 a1       	ldd	r27, Z+38	; 0x26
     5c2:	1c 93       	st	X, r17
  
  if (f->tail == f->end) {
     5c4:	45 a1       	ldd	r20, Z+37	; 0x25
     5c6:	56 a1       	ldd	r21, Z+38	; 0x26
     5c8:	81 a1       	ldd	r24, Z+33	; 0x21
     5ca:	92 a1       	ldd	r25, Z+34	; 0x22
     5cc:	48 17       	cp	r20, r24
     5ce:	59 07       	cpc	r21, r25
     5d0:	19 f4       	brne	.+6      	; 0x5d8 <afsk_putchar+0x112>
    f->tail = f->begin;
     5d2:	87 8d       	ldd	r24, Z+31	; 0x1f
     5d4:	90 a1       	ldd	r25, Z+32	; 0x20
     5d6:	03 c0       	rjmp	.+6      	; 0x5de <afsk_putchar+0x118>
  } else {
    f->tail++;
     5d8:	85 a1       	ldd	r24, Z+37	; 0x25
     5da:	96 a1       	ldd	r25, Z+38	; 0x26
     5dc:	01 96       	adiw	r24, 0x01	; 1
     5de:	96 a3       	std	Z+38, r25	; 0x26
     5e0:	85 a3       	std	Z+37, r24	; 0x25
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     5e2:	2f bf       	out	0x3f, r18	; 63
}
     5e4:	df 91       	pop	r29
     5e6:	cf 91       	pop	r28
     5e8:	1f 91       	pop	r17
     5ea:	0f 91       	pop	r16
     5ec:	08 95       	ret

000005ee <afsk_getchar>:

int afsk_getchar(void) {
    if (fifo_isempty_locked(&AFSK_modem->rxFifo)) {
     5ee:	e0 91 f3 03 	lds	r30, 0x03F3
     5f2:	f0 91 f4 03 	lds	r31, 0x03F4
  f->head = f->tail;
}

inline bool fifo_isempty_locked(const FIFOBuffer *f) {
  bool result;
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     5f6:	4f b7       	in	r20, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     5f8:	f8 94       	cli
  unsigned char * volatile head;
  unsigned char * volatile tail;
} FIFOBuffer;

inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
     5fa:	eb 58       	subi	r30, 0x8B	; 139
     5fc:	ff 4f       	sbci	r31, 0xFF	; 255
     5fe:	24 81       	ldd	r18, Z+4	; 0x04
     600:	35 81       	ldd	r19, Z+5	; 0x05
     602:	86 81       	ldd	r24, Z+6	; 0x06
     604:	97 81       	ldd	r25, Z+7	; 0x07
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     606:	4f bf       	out	0x3f, r20	; 63
     608:	28 17       	cp	r18, r24
     60a:	39 07       	cpc	r19, r25
     60c:	e9 f0       	breq	.+58     	; 0x648 <afsk_getchar+0x5a>
        return EOF;
    } else {
        return fifo_pop_locked(&AFSK_modem->rxFifo);
     60e:	e0 91 f3 03 	lds	r30, 0x03F3
     612:	f0 91 f4 03 	lds	r31, 0x03F4
  }
}

inline unsigned char fifo_pop_locked(FIFOBuffer *f) {
  unsigned char c;
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     616:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     618:	f8 94       	cli
    f->tail++;
  }
}

inline unsigned char fifo_pop(FIFOBuffer *f) {
  if(f->head == f->end) {
     61a:	eb 58       	subi	r30, 0x8B	; 139
     61c:	ff 4f       	sbci	r31, 0xFF	; 255
     61e:	a4 81       	ldd	r26, Z+4	; 0x04
     620:	b5 81       	ldd	r27, Z+5	; 0x05
     622:	22 81       	ldd	r18, Z+2	; 0x02
     624:	33 81       	ldd	r19, Z+3	; 0x03
     626:	a2 17       	cp	r26, r18
     628:	b3 07       	cpc	r27, r19
     62a:	19 f4       	brne	.+6      	; 0x632 <afsk_getchar+0x44>
    f->head = f->begin;
     62c:	20 81       	ld	r18, Z
     62e:	31 81       	ldd	r19, Z+1	; 0x01
     630:	05 c0       	rjmp	.+10     	; 0x63c <afsk_getchar+0x4e>
    return *(f->end);
  } else {
    return *(f->head++);
     632:	a4 81       	ldd	r26, Z+4	; 0x04
     634:	b5 81       	ldd	r27, Z+5	; 0x05
     636:	9d 01       	movw	r18, r26
     638:	2f 5f       	subi	r18, 0xFF	; 255
     63a:	3f 4f       	sbci	r19, 0xFF	; 255
     63c:	35 83       	std	Z+5, r19	; 0x05
     63e:	24 83       	std	Z+4, r18	; 0x04
     640:	8c 91       	ld	r24, X
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     642:	9f bf       	out	0x3f, r25	; 63
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	08 95       	ret
    fifo_push_locked(&AFSK_modem->txFifo, c);
}

int afsk_getchar(void) {
    if (fifo_isempty_locked(&AFSK_modem->rxFifo)) {
        return EOF;
     648:	8f ef       	ldi	r24, 0xFF	; 255
     64a:	9f ef       	ldi	r25, 0xFF	; 255
    } else {
        return fifo_pop_locked(&AFSK_modem->rxFifo);
    }
}
     64c:	08 95       	ret

0000064e <AFSK_hw_refDetect>:
void AFSK_hw_refDetect(void) {
    // This is manual for now
    #if ADC_REFERENCE == REF_5V
        hw_5v_ref = true;
    #else
        hw_5v_ref = false;
     64e:	10 92 3c 01 	sts	0x013C, r1
     652:	08 95       	ret

00000654 <AFSK_hw_init>:
     654:	10 92 3c 01 	sts	0x013C, r1
void AFSK_hw_init(void) {
    // Set up ADC

    AFSK_hw_refDetect();

    TCCR1A = 0;                                    
     658:	10 92 80 00 	sts	0x0080, r1
    TCCR1B = _BV(CS10) | _BV(WGM13) | _BV(WGM12);
     65c:	89 e1       	ldi	r24, 0x19	; 25
     65e:	80 93 81 00 	sts	0x0081, r24
    ICR1 = (((CPU_FREQ+FREQUENCY_CORRECTION)) / 9600) - 1;
     662:	81 e8       	ldi	r24, 0x81	; 129
     664:	96 e0       	ldi	r25, 0x06	; 6
     666:	90 93 87 00 	sts	0x0087, r25
     66a:	80 93 86 00 	sts	0x0086, r24

    if (hw_5v_ref) {
     66e:	80 91 3c 01 	lds	r24, 0x013C
     672:	88 23       	and	r24, r24
     674:	21 f0       	breq	.+8      	; 0x67e <AFSK_hw_init+0x2a>
        ADMUX = _BV(REFS0) | 0;
     676:	80 e4       	ldi	r24, 0x40	; 64
     678:	80 93 7c 00 	sts	0x007C, r24
     67c:	02 c0       	rjmp	.+4      	; 0x682 <AFSK_hw_init+0x2e>
    } else {
        ADMUX = 0;
     67e:	10 92 7c 00 	sts	0x007C, r1
    }

    ADC_DDR  &= ~_BV(0);
     682:	38 98       	cbi	0x07, 0	; 7
    ADC_PORT &= ~_BV(0);
     684:	40 98       	cbi	0x08, 0	; 8
    DIDR0 |= _BV(0);
     686:	80 91 7e 00 	lds	r24, 0x007E
     68a:	81 60       	ori	r24, 0x01	; 1
     68c:	80 93 7e 00 	sts	0x007E, r24
    ADCSRB =    _BV(ADTS2) |
     690:	87 e0       	ldi	r24, 0x07	; 7
     692:	80 93 7b 00 	sts	0x007B, r24
                _BV(ADTS1) |
                _BV(ADTS0);  
    ADCSRA =    _BV(ADEN) |
     696:	8c ee       	ldi	r24, 0xEC	; 236
     698:	80 93 7a 00 	sts	0x007A, r24
                _BV(ADSC) |
                _BV(ADATE)|
                _BV(ADIE) |
                _BV(ADPS2);

    AFSK_DAC_INIT();
     69c:	8a b1       	in	r24, 0x0a	; 10
     69e:	88 6f       	ori	r24, 0xF8	; 248
     6a0:	8a b9       	out	0x0a, r24	; 10
    LED_TX_INIT();
     6a2:	21 9a       	sbi	0x04, 1	; 4
    LED_RX_INIT();
     6a4:	22 9a       	sbi	0x04, 2	; 4
     6a6:	08 95       	ret

000006a8 <AFSK_init>:
}

void AFSK_init(Afsk *afsk) {
     6a8:	0f 93       	push	r16
     6aa:	1f 93       	push	r17
     6ac:	cf 93       	push	r28
     6ae:	df 93       	push	r29
     6b0:	cd b7       	in	r28, 0x3d	; 61
     6b2:	de b7       	in	r29, 0x3e	; 62
     6b4:	2e 97       	sbiw	r28, 0x0e	; 14
     6b6:	0f b6       	in	r0, 0x3f	; 63
     6b8:	f8 94       	cli
     6ba:	de bf       	out	0x3e, r29	; 62
     6bc:	0f be       	out	0x3f, r0	; 63
     6be:	cd bf       	out	0x3d, r28	; 61
     6c0:	8c 01       	movw	r16, r24
    // Allocate modem struct memory
    memset(afsk, 0, sizeof(*afsk));
     6c2:	8a ec       	ldi	r24, 0xCA	; 202
     6c4:	d8 01       	movw	r26, r16
     6c6:	1d 92       	st	X+, r1
     6c8:	8a 95       	dec	r24
     6ca:	e9 f7       	brne	.-6      	; 0x6c6 <AFSK_init+0x1e>
    AFSK_modem = afsk;
     6cc:	10 93 f4 03 	sts	0x03F4, r17
     6d0:	00 93 f3 03 	sts	0x03F3, r16
    // Set phase increment
    afsk->phaseInc = MARK_INC;
     6d4:	80 e4       	ldi	r24, 0x40	; 64
     6d6:	90 e0       	ldi	r25, 0x00	; 0
     6d8:	f8 01       	movw	r30, r16
     6da:	96 8f       	std	Z+30, r25	; 0x1e
     6dc:	85 8f       	std	Z+29, r24	; 0x1d
    // Initialise FIFO buffers
    fifo_init(&afsk->delayFifo, (uint8_t *)afsk->delayBuf, sizeof(afsk->delayBuf));
     6de:	c8 01       	movw	r24, r16
     6e0:	80 59       	subi	r24, 0x90	; 144
     6e2:	9f 4f       	sbci	r25, 0xFF	; 255
  }
  return c;
}

inline void fifo_init(FIFOBuffer *f, unsigned char *buffer, size_t size) {
  f->head = f->tail = f->begin = buffer;
     6e4:	e8 59       	subi	r30, 0x98	; 152
     6e6:	ff 4f       	sbci	r31, 0xFF	; 255
     6e8:	91 83       	std	Z+1, r25	; 0x01
     6ea:	80 83       	st	Z, r24
     6ec:	97 83       	std	Z+7, r25	; 0x07
     6ee:	86 83       	std	Z+6, r24	; 0x06
     6f0:	95 83       	std	Z+5, r25	; 0x05
     6f2:	84 83       	std	Z+4, r24	; 0x04
  f->end = buffer + size -1;
     6f4:	04 96       	adiw	r24, 0x04	; 4
     6f6:	93 83       	std	Z+3, r25	; 0x03
     6f8:	82 83       	std	Z+2, r24	; 0x02
    fifo_init(&afsk->rxFifo, afsk->rxBuf, sizeof(afsk->rxBuf));
     6fa:	09 96       	adiw	r24, 0x09	; 9
  }
  return c;
}

inline void fifo_init(FIFOBuffer *f, unsigned char *buffer, size_t size) {
  f->head = f->tail = f->begin = buffer;
     6fc:	d8 01       	movw	r26, r16
     6fe:	ab 58       	subi	r26, 0x8B	; 139
     700:	bf 4f       	sbci	r27, 0xFF	; 255
     702:	11 96       	adiw	r26, 0x01	; 1
     704:	9c 93       	st	X, r25
     706:	8e 93       	st	-X, r24
     708:	17 96       	adiw	r26, 0x07	; 7
     70a:	9c 93       	st	X, r25
     70c:	8e 93       	st	-X, r24
     70e:	16 97       	sbiw	r26, 0x06	; 6
     710:	15 96       	adiw	r26, 0x05	; 5
     712:	9c 93       	st	X, r25
     714:	8e 93       	st	-X, r24
     716:	14 97       	sbiw	r26, 0x04	; 4
  f->end = buffer + size -1;
     718:	cf 96       	adiw	r24, 0x3f	; 63
     71a:	13 96       	adiw	r26, 0x03	; 3
     71c:	9c 93       	st	X, r25
     71e:	8e 93       	st	-X, r24
     720:	12 97       	sbiw	r26, 0x02	; 2
    fifo_init(&afsk->txFifo, afsk->txBuf, sizeof(afsk->txBuf));
     722:	85 59       	subi	r24, 0x95	; 149
     724:	91 09       	sbc	r25, r1
  }
  return c;
}

inline void fifo_init(FIFOBuffer *f, unsigned char *buffer, size_t size) {
  f->head = f->tail = f->begin = buffer;
     726:	d8 01       	movw	r26, r16
     728:	90 96       	adiw	r26, 0x20	; 32
     72a:	9c 93       	st	X, r25
     72c:	8e 93       	st	-X, r24
     72e:	5f 97       	sbiw	r26, 0x1f	; 31
     730:	96 96       	adiw	r26, 0x26	; 38
     732:	9c 93       	st	X, r25
     734:	8e 93       	st	-X, r24
     736:	95 97       	sbiw	r26, 0x25	; 37
     738:	94 96       	adiw	r26, 0x24	; 36
     73a:	9c 93       	st	X, r25
     73c:	8e 93       	st	-X, r24
     73e:	93 97       	sbiw	r26, 0x23	; 35
  f->end = buffer + size -1;
     740:	cf 96       	adiw	r24, 0x3f	; 63
     742:	92 96       	adiw	r26, 0x22	; 34
     744:	9c 93       	st	X, r25
     746:	8e 93       	st	-X, r24
     748:	91 97       	sbiw	r26, 0x21	; 33
     74a:	84 e0       	ldi	r24, 0x04	; 4
     74c:	90 e0       	ldi	r25, 0x00	; 0
inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     74e:	a6 81       	ldd	r26, Z+6	; 0x06
     750:	b7 81       	ldd	r27, Z+7	; 0x07
     752:	1c 92       	st	X, r1
  
  if (f->tail == f->end) {
     754:	46 81       	ldd	r20, Z+6	; 0x06
     756:	57 81       	ldd	r21, Z+7	; 0x07
     758:	22 81       	ldd	r18, Z+2	; 0x02
     75a:	33 81       	ldd	r19, Z+3	; 0x03
     75c:	42 17       	cp	r20, r18
     75e:	53 07       	cpc	r21, r19
     760:	19 f4       	brne	.+6      	; 0x768 <AFSK_init+0xc0>
    f->tail = f->begin;
     762:	20 81       	ld	r18, Z
     764:	31 81       	ldd	r19, Z+1	; 0x01
     766:	04 c0       	rjmp	.+8      	; 0x770 <AFSK_init+0xc8>
  } else {
    f->tail++;
     768:	26 81       	ldd	r18, Z+6	; 0x06
     76a:	37 81       	ldd	r19, Z+7	; 0x07
     76c:	2f 5f       	subi	r18, 0xFF	; 255
     76e:	3f 4f       	sbci	r19, 0xFF	; 255
     770:	37 83       	std	Z+7, r19	; 0x07
     772:	26 83       	std	Z+6, r18	; 0x06
     774:	01 97       	sbiw	r24, 0x01	; 1

    // Fill delay FIFO with zeroes
    for (int i = 0; i<SAMPLESPERBIT / 2; i++) {
     776:	59 f7       	brne	.-42     	; 0x74e <AFSK_init+0xa6>
        fifo_push(&afsk->delayFifo, 0);
    }

    AFSK_hw_init();
     778:	0e 94 2a 03 	call	0x654	; 0x654 <AFSK_hw_init>

    // Set up streams
    FILE afsk_fd = FDEV_SETUP_STREAM(afsk_putchar, afsk_getchar, _FDEV_SETUP_RW);
     77c:	8e e0       	ldi	r24, 0x0E	; 14
     77e:	fe 01       	movw	r30, r28
     780:	31 96       	adiw	r30, 0x01	; 1
     782:	df 01       	movw	r26, r30
     784:	98 2f       	mov	r25, r24
     786:	1d 92       	st	X+, r1
     788:	9a 95       	dec	r25
     78a:	e9 f7       	brne	.-6      	; 0x786 <AFSK_init+0xde>
    afsk->fd = afsk_fd;
     78c:	93 e0       	ldi	r25, 0x03	; 3
     78e:	9c 83       	std	Y+4, r25	; 0x04
     790:	23 e6       	ldi	r18, 0x63	; 99
     792:	32 e0       	ldi	r19, 0x02	; 2
     794:	3a 87       	std	Y+10, r19	; 0x0a
     796:	29 87       	std	Y+9, r18	; 0x09
     798:	27 ef       	ldi	r18, 0xF7	; 247
     79a:	32 e0       	ldi	r19, 0x02	; 2
     79c:	3c 87       	std	Y+12, r19	; 0x0c
     79e:	2b 87       	std	Y+11, r18	; 0x0b
     7a0:	d8 01       	movw	r26, r16
     7a2:	01 90       	ld	r0, Z+
     7a4:	0d 92       	st	X+, r0
     7a6:	8a 95       	dec	r24
     7a8:	e1 f7       	brne	.-8      	; 0x7a2 <AFSK_init+0xfa>
}
     7aa:	2e 96       	adiw	r28, 0x0e	; 14
     7ac:	0f b6       	in	r0, 0x3f	; 63
     7ae:	f8 94       	cli
     7b0:	de bf       	out	0x3e, r29	; 62
     7b2:	0f be       	out	0x3f, r0	; 63
     7b4:	cd bf       	out	0x3d, r28	; 61
     7b6:	df 91       	pop	r29
     7b8:	cf 91       	pop	r28
     7ba:	1f 91       	pop	r17
     7bc:	0f 91       	pop	r16
     7be:	08 95       	ret

000007c0 <AFSK_transmit>:
    } else {
        return fifo_pop_locked(&AFSK_modem->rxFifo);
    }
}

void AFSK_transmit(char *buffer, size_t size) {
     7c0:	0f 93       	push	r16
     7c2:	1f 93       	push	r17
     7c4:	cf 93       	push	r28
     7c6:	df 93       	push	r29
    fifo_flush(&AFSK_modem->txFifo);
     7c8:	e0 91 f3 03 	lds	r30, 0x03F3
     7cc:	f0 91 f4 03 	lds	r31, 0x03F4
    return *(f->head++);
  }
}

inline void fifo_flush(FIFOBuffer *f) {
  f->head = f->tail;
     7d0:	25 a1       	ldd	r18, Z+37	; 0x25
     7d2:	36 a1       	ldd	r19, Z+38	; 0x26
     7d4:	34 a3       	std	Z+36, r19	; 0x24
     7d6:	23 a3       	std	Z+35, r18	; 0x23
     7d8:	ec 01       	movw	r28, r24
     7da:	8c 01       	movw	r16, r24
     7dc:	06 0f       	add	r16, r22
     7de:	17 1f       	adc	r17, r23
    int i = 0;
    while (size--) {
     7e0:	c0 17       	cp	r28, r16
     7e2:	d1 07       	cpc	r29, r17
     7e4:	21 f0       	breq	.+8      	; 0x7ee <AFSK_transmit+0x2e>
        afsk_putchar(buffer[i++]);
     7e6:	89 91       	ld	r24, Y+
     7e8:	0e 94 63 02 	call	0x4c6	; 0x4c6 <afsk_putchar>
     7ec:	f9 cf       	rjmp	.-14     	; 0x7e0 <AFSK_transmit+0x20>
    }
}
     7ee:	df 91       	pop	r29
     7f0:	cf 91       	pop	r28
     7f2:	1f 91       	pop	r17
     7f4:	0f 91       	pop	r16
     7f6:	08 95       	ret

000007f8 <AFSK_dac_isr>:

uint8_t AFSK_dac_isr(Afsk *afsk) {
     7f8:	dc 01       	movw	r26, r24
    if (afsk->sampleIndex == 0) {
     7fa:	56 96       	adiw	r26, 0x16	; 22
     7fc:	8c 91       	ld	r24, X
     7fe:	56 97       	sbiw	r26, 0x16	; 22
     800:	81 11       	cpse	r24, r1
     802:	ec c0       	rjmp	.+472    	; 0x9dc <__stack+0xdd>
        if (afsk->txBit == 0) {
     804:	58 96       	adiw	r26, 0x18	; 24
     806:	8c 91       	ld	r24, X
     808:	58 97       	sbiw	r26, 0x18	; 24
     80a:	81 11       	cpse	r24, r1
     80c:	a2 c0       	rjmp	.+324    	; 0x952 <__stack+0x53>
  unsigned char * volatile head;
  unsigned char * volatile tail;
} FIFOBuffer;

inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
     80e:	93 96       	adiw	r26, 0x23	; 35
     810:	4d 91       	ld	r20, X+
     812:	5c 91       	ld	r21, X
     814:	94 97       	sbiw	r26, 0x24	; 36
     816:	95 96       	adiw	r26, 0x25	; 37
     818:	2d 91       	ld	r18, X+
     81a:	3c 91       	ld	r19, X
     81c:	96 97       	sbiw	r26, 0x26	; 38
            if (fifo_isempty(&afsk->txFifo) && afsk->tailLength == 0) {
     81e:	42 17       	cp	r20, r18
     820:	53 07       	cpc	r21, r19
     822:	39 f4       	brne	.+14     	; 0x832 <AFSK_dac_isr+0x3a>
     824:	54 96       	adiw	r26, 0x14	; 20
     826:	2d 91       	ld	r18, X+
     828:	3c 91       	ld	r19, X
     82a:	55 97       	sbiw	r26, 0x15	; 21
     82c:	23 2b       	or	r18, r19
     82e:	09 f4       	brne	.+2      	; 0x832 <AFSK_dac_isr+0x3a>
     830:	60 c0       	rjmp	.+192    	; 0x8f2 <AFSK_dac_isr+0xfa>
                AFSK_DAC_IRQ_STOP();
                afsk->sending = false;
                LED_TX_OFF();
                return 0;
            } else {
                if (!afsk->bitStuff) afsk->bitstuffCount = 0;
     832:	59 96       	adiw	r26, 0x19	; 25
     834:	9c 91       	ld	r25, X
     836:	59 97       	sbiw	r26, 0x19	; 25
     838:	91 11       	cpse	r25, r1
     83a:	03 c0       	rjmp	.+6      	; 0x842 <AFSK_dac_isr+0x4a>
     83c:	5a 96       	adiw	r26, 0x1a	; 26
     83e:	1c 92       	st	X, r1
     840:	5a 97       	sbiw	r26, 0x1a	; 26
                afsk->bitStuff = true;
     842:	91 e0       	ldi	r25, 0x01	; 1
     844:	59 96       	adiw	r26, 0x19	; 25
     846:	9c 93       	st	X, r25
     848:	59 97       	sbiw	r26, 0x19	; 25
                if (afsk->preambleLength == 0) {
     84a:	52 96       	adiw	r26, 0x12	; 18
     84c:	2d 91       	ld	r18, X+
     84e:	3c 91       	ld	r19, X
     850:	53 97       	sbiw	r26, 0x13	; 19
     852:	21 15       	cp	r18, r1
     854:	31 05       	cpc	r19, r1
     856:	99 f5       	brne	.+102    	; 0x8be <AFSK_dac_isr+0xc6>
     858:	93 96       	adiw	r26, 0x23	; 35
     85a:	4d 91       	ld	r20, X+
     85c:	5c 91       	ld	r21, X
     85e:	94 97       	sbiw	r26, 0x24	; 36
     860:	95 96       	adiw	r26, 0x25	; 37
     862:	2d 91       	ld	r18, X+
     864:	3c 91       	ld	r19, X
     866:	96 97       	sbiw	r26, 0x26	; 38
                    if (fifo_isempty(&afsk->txFifo)) {
     868:	42 17       	cp	r20, r18
     86a:	53 07       	cpc	r21, r19
     86c:	59 f4       	brne	.+22     	; 0x884 <AFSK_dac_isr+0x8c>
                        afsk->tailLength--;
     86e:	54 96       	adiw	r26, 0x14	; 20
     870:	2d 91       	ld	r18, X+
     872:	3c 91       	ld	r19, X
     874:	55 97       	sbiw	r26, 0x15	; 21
     876:	21 50       	subi	r18, 0x01	; 1
     878:	31 09       	sbc	r19, r1
     87a:	55 96       	adiw	r26, 0x15	; 21
     87c:	3c 93       	st	X, r19
     87e:	2e 93       	st	-X, r18
     880:	54 97       	sbiw	r26, 0x14	; 20
     882:	23 c0       	rjmp	.+70     	; 0x8ca <AFSK_dac_isr+0xd2>
    f->tail++;
  }
}

inline unsigned char fifo_pop(FIFOBuffer *f) {
  if(f->head == f->end) {
     884:	93 96       	adiw	r26, 0x23	; 35
     886:	ed 91       	ld	r30, X+
     888:	fc 91       	ld	r31, X
     88a:	94 97       	sbiw	r26, 0x24	; 36
     88c:	91 96       	adiw	r26, 0x21	; 33
     88e:	2d 91       	ld	r18, X+
     890:	3c 91       	ld	r19, X
     892:	92 97       	sbiw	r26, 0x22	; 34
     894:	e2 17       	cp	r30, r18
     896:	f3 07       	cpc	r31, r19
     898:	29 f4       	brne	.+10     	; 0x8a4 <AFSK_dac_isr+0xac>
    f->head = f->begin;
     89a:	5f 96       	adiw	r26, 0x1f	; 31
     89c:	2d 91       	ld	r18, X+
     89e:	3c 91       	ld	r19, X
     8a0:	90 97       	sbiw	r26, 0x20	; 32
     8a2:	07 c0       	rjmp	.+14     	; 0x8b2 <AFSK_dac_isr+0xba>
    return *(f->end);
  } else {
    return *(f->head++);
     8a4:	93 96       	adiw	r26, 0x23	; 35
     8a6:	ed 91       	ld	r30, X+
     8a8:	fc 91       	ld	r31, X
     8aa:	94 97       	sbiw	r26, 0x24	; 36
     8ac:	9f 01       	movw	r18, r30
     8ae:	2f 5f       	subi	r18, 0xFF	; 255
     8b0:	3f 4f       	sbci	r19, 0xFF	; 255
     8b2:	94 96       	adiw	r26, 0x24	; 36
     8b4:	3c 93       	st	X, r19
     8b6:	2e 93       	st	-X, r18
     8b8:	93 97       	sbiw	r26, 0x23	; 35
     8ba:	90 81       	ld	r25, Z
     8bc:	07 c0       	rjmp	.+14     	; 0x8cc <AFSK_dac_isr+0xd4>
                        afsk->currentOutputByte = HDLC_FLAG;
                    } else {
                        afsk->currentOutputByte = fifo_pop(&afsk->txFifo);
                    }
                } else {
                    afsk->preambleLength--;
     8be:	21 50       	subi	r18, 0x01	; 1
     8c0:	31 09       	sbc	r19, r1
     8c2:	53 96       	adiw	r26, 0x13	; 19
     8c4:	3c 93       	st	X, r19
     8c6:	2e 93       	st	-X, r18
     8c8:	52 97       	sbiw	r26, 0x12	; 18
                    afsk->currentOutputByte = HDLC_FLAG;
     8ca:	9e e7       	ldi	r25, 0x7E	; 126
     8cc:	57 96       	adiw	r26, 0x17	; 23
     8ce:	9c 93       	st	X, r25
     8d0:	57 97       	sbiw	r26, 0x17	; 23
                }
                if (afsk->currentOutputByte == AX25_ESC) {
     8d2:	57 96       	adiw	r26, 0x17	; 23
     8d4:	9c 91       	ld	r25, X
     8d6:	57 97       	sbiw	r26, 0x17	; 23
     8d8:	9b 31       	cpi	r25, 0x1B	; 27
     8da:	89 f5       	brne	.+98     	; 0x93e <__stack+0x3f>
  unsigned char * volatile head;
  unsigned char * volatile tail;
} FIFOBuffer;

inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
     8dc:	93 96       	adiw	r26, 0x23	; 35
     8de:	4d 91       	ld	r20, X+
     8e0:	5c 91       	ld	r21, X
     8e2:	94 97       	sbiw	r26, 0x24	; 36
     8e4:	95 96       	adiw	r26, 0x25	; 37
     8e6:	2d 91       	ld	r18, X+
     8e8:	3c 91       	ld	r19, X
     8ea:	96 97       	sbiw	r26, 0x26	; 38
                    if (fifo_isempty(&afsk->txFifo)) {
     8ec:	42 17       	cp	r20, r18
     8ee:	53 07       	cpc	r21, r19
     8f0:	39 f4       	brne	.+14     	; 0x900 <__stack+0x1>
                        AFSK_DAC_IRQ_STOP();
     8f2:	10 92 3d 01 	sts	0x013D, r1
                        afsk->sending = false;
     8f6:	a9 59       	subi	r26, 0x99	; 153
     8f8:	bf 4f       	sbci	r27, 0xFF	; 255
     8fa:	1c 92       	st	X, r1
                        LED_TX_OFF();
     8fc:	29 98       	cbi	0x05, 1	; 5
                        return 0;
     8fe:	08 95       	ret
    f->tail++;
  }
}

inline unsigned char fifo_pop(FIFOBuffer *f) {
  if(f->head == f->end) {
     900:	93 96       	adiw	r26, 0x23	; 35
     902:	ed 91       	ld	r30, X+
     904:	fc 91       	ld	r31, X
     906:	94 97       	sbiw	r26, 0x24	; 36
     908:	91 96       	adiw	r26, 0x21	; 33
     90a:	8d 91       	ld	r24, X+
     90c:	9c 91       	ld	r25, X
     90e:	92 97       	sbiw	r26, 0x22	; 34
     910:	e8 17       	cp	r30, r24
     912:	f9 07       	cpc	r31, r25
     914:	29 f4       	brne	.+10     	; 0x920 <__stack+0x21>
    f->head = f->begin;
     916:	5f 96       	adiw	r26, 0x1f	; 31
     918:	8d 91       	ld	r24, X+
     91a:	9c 91       	ld	r25, X
     91c:	90 97       	sbiw	r26, 0x20	; 32
     91e:	06 c0       	rjmp	.+12     	; 0x92c <__stack+0x2d>
    return *(f->end);
  } else {
    return *(f->head++);
     920:	93 96       	adiw	r26, 0x23	; 35
     922:	ed 91       	ld	r30, X+
     924:	fc 91       	ld	r31, X
     926:	94 97       	sbiw	r26, 0x24	; 36
     928:	cf 01       	movw	r24, r30
     92a:	01 96       	adiw	r24, 0x01	; 1
     92c:	94 96       	adiw	r26, 0x24	; 36
     92e:	9c 93       	st	X, r25
     930:	8e 93       	st	-X, r24
     932:	93 97       	sbiw	r26, 0x23	; 35
     934:	80 81       	ld	r24, Z
                    } else {
                        afsk->currentOutputByte = fifo_pop(&afsk->txFifo);
     936:	57 96       	adiw	r26, 0x17	; 23
     938:	8c 93       	st	X, r24
     93a:	57 97       	sbiw	r26, 0x17	; 23
     93c:	06 c0       	rjmp	.+12     	; 0x94a <__stack+0x4b>
                    }
                } else if (afsk->currentOutputByte == HDLC_FLAG || afsk->currentOutputByte == HDLC_RESET) {
     93e:	9e 57       	subi	r25, 0x7E	; 126
     940:	92 30       	cpi	r25, 0x02	; 2
     942:	18 f4       	brcc	.+6      	; 0x94a <__stack+0x4b>
                    afsk->bitStuff = false;
     944:	59 96       	adiw	r26, 0x19	; 25
     946:	1c 92       	st	X, r1
     948:	59 97       	sbiw	r26, 0x19	; 25
                }
            }
            afsk->txBit = 0x01;
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	58 96       	adiw	r26, 0x18	; 24
     94e:	8c 93       	st	X, r24
     950:	58 97       	sbiw	r26, 0x18	; 24
        }

        if (afsk->bitStuff && afsk->bitstuffCount >= BIT_STUFF_LEN) {
     952:	59 96       	adiw	r26, 0x19	; 25
     954:	8c 91       	ld	r24, X
     956:	59 97       	sbiw	r26, 0x19	; 25
     958:	5d 96       	adiw	r26, 0x1d	; 29
     95a:	2d 91       	ld	r18, X+
     95c:	3c 91       	ld	r19, X
     95e:	5e 97       	sbiw	r26, 0x1e	; 30
     960:	88 23       	and	r24, r24
     962:	a9 f0       	breq	.+42     	; 0x98e <__stack+0x8f>
     964:	5a 96       	adiw	r26, 0x1a	; 26
     966:	8c 91       	ld	r24, X
     968:	5a 97       	sbiw	r26, 0x1a	; 26
     96a:	85 30       	cpi	r24, 0x05	; 5
     96c:	80 f0       	brcs	.+32     	; 0x98e <__stack+0x8f>
            afsk->bitstuffCount = 0;
     96e:	5a 96       	adiw	r26, 0x1a	; 26
     970:	1c 92       	st	X, r1
     972:	5a 97       	sbiw	r26, 0x1a	; 26
            afsk->phaseInc = SWITCH_TONE(afsk->phaseInc);
     974:	20 34       	cpi	r18, 0x40	; 64
     976:	31 05       	cpc	r19, r1
     978:	19 f0       	breq	.+6      	; 0x980 <__stack+0x81>
     97a:	80 e4       	ldi	r24, 0x40	; 64
     97c:	90 e0       	ldi	r25, 0x00	; 0
     97e:	02 c0       	rjmp	.+4      	; 0x984 <__stack+0x85>
     980:	85 e7       	ldi	r24, 0x75	; 117
     982:	90 e0       	ldi	r25, 0x00	; 0
     984:	5e 96       	adiw	r26, 0x1e	; 30
     986:	9c 93       	st	X, r25
     988:	8e 93       	st	-X, r24
     98a:	5d 97       	sbiw	r26, 0x1d	; 29
     98c:	23 c0       	rjmp	.+70     	; 0x9d4 <__stack+0xd5>
        } else {
            if (afsk->currentOutputByte & afsk->txBit) {
     98e:	58 96       	adiw	r26, 0x18	; 24
     990:	8c 91       	ld	r24, X
     992:	58 97       	sbiw	r26, 0x18	; 24
     994:	57 96       	adiw	r26, 0x17	; 23
     996:	9c 91       	ld	r25, X
     998:	57 97       	sbiw	r26, 0x17	; 23
     99a:	98 23       	and	r25, r24
     99c:	41 f0       	breq	.+16     	; 0x9ae <__stack+0xaf>
                afsk->bitstuffCount++;
     99e:	5a 96       	adiw	r26, 0x1a	; 26
     9a0:	9c 91       	ld	r25, X
     9a2:	5a 97       	sbiw	r26, 0x1a	; 26
     9a4:	9f 5f       	subi	r25, 0xFF	; 255
     9a6:	5a 96       	adiw	r26, 0x1a	; 26
     9a8:	9c 93       	st	X, r25
     9aa:	5a 97       	sbiw	r26, 0x1a	; 26
     9ac:	0f c0       	rjmp	.+30     	; 0x9cc <__stack+0xcd>
            } else {
                afsk->bitstuffCount = 0;
     9ae:	5a 96       	adiw	r26, 0x1a	; 26
     9b0:	1c 92       	st	X, r1
     9b2:	5a 97       	sbiw	r26, 0x1a	; 26
                afsk->phaseInc = SWITCH_TONE(afsk->phaseInc);
     9b4:	20 34       	cpi	r18, 0x40	; 64
     9b6:	31 05       	cpc	r19, r1
     9b8:	19 f0       	breq	.+6      	; 0x9c0 <__stack+0xc1>
     9ba:	20 e4       	ldi	r18, 0x40	; 64
     9bc:	30 e0       	ldi	r19, 0x00	; 0
     9be:	02 c0       	rjmp	.+4      	; 0x9c4 <__stack+0xc5>
     9c0:	25 e7       	ldi	r18, 0x75	; 117
     9c2:	30 e0       	ldi	r19, 0x00	; 0
     9c4:	5e 96       	adiw	r26, 0x1e	; 30
     9c6:	3c 93       	st	X, r19
     9c8:	2e 93       	st	-X, r18
     9ca:	5d 97       	sbiw	r26, 0x1d	; 29
            }
            afsk->txBit <<= 1;
     9cc:	88 0f       	add	r24, r24
     9ce:	58 96       	adiw	r26, 0x18	; 24
     9d0:	8c 93       	st	X, r24
     9d2:	58 97       	sbiw	r26, 0x18	; 24
        }

        afsk->sampleIndex = SAMPLESPERBIT;
     9d4:	88 e0       	ldi	r24, 0x08	; 8
     9d6:	56 96       	adiw	r26, 0x16	; 22
     9d8:	8c 93       	st	X, r24
     9da:	56 97       	sbiw	r26, 0x16	; 22
    }

    afsk->phaseAcc += afsk->phaseInc;
     9dc:	5d 96       	adiw	r26, 0x1d	; 29
     9de:	ed 91       	ld	r30, X+
     9e0:	fc 91       	ld	r31, X
     9e2:	5e 97       	sbiw	r26, 0x1e	; 30
     9e4:	5b 96       	adiw	r26, 0x1b	; 27
     9e6:	8d 91       	ld	r24, X+
     9e8:	9c 91       	ld	r25, X
     9ea:	5c 97       	sbiw	r26, 0x1c	; 28
     9ec:	e8 0f       	add	r30, r24
     9ee:	f9 1f       	adc	r31, r25
    afsk->phaseAcc %= SIN_LEN;
     9f0:	9f 01       	movw	r18, r30
     9f2:	31 70       	andi	r19, 0x01	; 1
     9f4:	5c 96       	adiw	r26, 0x1c	; 28
     9f6:	3c 93       	st	X, r19
     9f8:	2e 93       	st	-X, r18
     9fa:	5b 97       	sbiw	r26, 0x1b	; 27
    afsk->sampleIndex--;
     9fc:	56 96       	adiw	r26, 0x16	; 22
     9fe:	8c 91       	ld	r24, X
     a00:	56 97       	sbiw	r26, 0x16	; 22
     a02:	81 50       	subi	r24, 0x01	; 1
     a04:	56 96       	adiw	r26, 0x16	; 22
     a06:	8c 93       	st	X, r24
    245, 246, 246, 247, 248, 248, 249, 249, 250, 250, 250, 251, 251, 252, 252, 252,
    253, 253, 253, 253, 254, 254, 254, 254, 254, 255, 255, 255, 255, 255, 255, 255,
};

inline static uint8_t sinSample(uint16_t i) {
    uint16_t newI = i % (SIN_LEN/2);
     a08:	ff 27       	eor	r31, r31
    newI = (newI >= (SIN_LEN/4)) ? (SIN_LEN/2 - newI -1) : newI;
     a0a:	e0 38       	cpi	r30, 0x80	; 128
     a0c:	f1 05       	cpc	r31, r1
     a0e:	30 f0       	brcs	.+12     	; 0xa1c <__stack+0x11d>
     a10:	8f ef       	ldi	r24, 0xFF	; 255
     a12:	90 e0       	ldi	r25, 0x00	; 0
     a14:	ac 01       	movw	r20, r24
     a16:	4e 1b       	sub	r20, r30
     a18:	5f 0b       	sbc	r21, r31
     a1a:	fa 01       	movw	r30, r20
    uint8_t sine = pgm_read_byte(&sin_table[newI]);
     a1c:	e8 59       	subi	r30, 0x98	; 152
     a1e:	ff 4f       	sbci	r31, 0xFF	; 255
     a20:	84 91       	lpm	r24, Z
    return (i >= (SIN_LEN/2)) ? (255 - sine) : sine;
     a22:	2f 3f       	cpi	r18, 0xFF	; 255
     a24:	31 05       	cpc	r19, r1
     a26:	11 f0       	breq	.+4      	; 0xa2c <__stack+0x12d>
     a28:	08 f0       	brcs	.+2      	; 0xa2c <__stack+0x12d>
     a2a:	80 95       	com	r24

    return sinSample(afsk->phaseAcc);
}
     a2c:	08 95       	ret

00000a2e <AFSK_adc_isr>:
    //digitalWrite(13, LOW);
    return ret;
}


void AFSK_adc_isr(Afsk *afsk, int8_t currentSample) {
     a2e:	ef 92       	push	r14
     a30:	ff 92       	push	r15
     a32:	0f 93       	push	r16
     a34:	1f 93       	push	r17
     a36:	cf 93       	push	r28
     a38:	df 93       	push	r29
     a3a:	fc 01       	movw	r30, r24
    // a sample delayed by (samples per bit / 2).
    // We then lowpass-filter the samples with a
    // Chebyshev filter. The lowpass filtering serves
    // to "smooth out" the variations in the samples.

    afsk->iirX[0] = afsk->iirX[1];
     a3c:	8c 01       	movw	r16, r24
     a3e:	01 54       	subi	r16, 0x41	; 65
     a40:	1f 4f       	sbci	r17, 0xFF	; 255
     a42:	d8 01       	movw	r26, r16
     a44:	4d 91       	ld	r20, X+
     a46:	5c 91       	ld	r21, X
     a48:	11 97       	sbiw	r26, 0x01	; 1
     a4a:	12 97       	sbiw	r26, 0x02	; 2
     a4c:	11 96       	adiw	r26, 0x01	; 1
     a4e:	5c 93       	st	X, r21
     a50:	4e 93       	st	-X, r20
    f->tail++;
  }
}

inline unsigned char fifo_pop(FIFOBuffer *f) {
  if(f->head == f->end) {
     a52:	a5 55       	subi	r26, 0x55	; 85
     a54:	b1 09       	sbc	r27, r1
     a56:	14 96       	adiw	r26, 0x04	; 4
     a58:	8d 91       	ld	r24, X+
     a5a:	9c 91       	ld	r25, X
     a5c:	15 97       	sbiw	r26, 0x05	; 5
     a5e:	12 96       	adiw	r26, 0x02	; 2
     a60:	2d 91       	ld	r18, X+
     a62:	3c 91       	ld	r19, X
     a64:	13 97       	sbiw	r26, 0x03	; 3
     a66:	82 17       	cp	r24, r18
     a68:	93 07       	cpc	r25, r19
     a6a:	21 f4       	brne	.+8      	; 0xa74 <AFSK_adc_isr+0x46>
    f->head = f->begin;
     a6c:	2d 91       	ld	r18, X+
     a6e:	3c 91       	ld	r19, X
     a70:	11 97       	sbiw	r26, 0x01	; 1
     a72:	07 c0       	rjmp	.+14     	; 0xa82 <AFSK_adc_isr+0x54>
    return *(f->end);
  } else {
    return *(f->head++);
     a74:	14 96       	adiw	r26, 0x04	; 4
     a76:	8d 91       	ld	r24, X+
     a78:	9c 91       	ld	r25, X
     a7a:	15 97       	sbiw	r26, 0x05	; 5
     a7c:	9c 01       	movw	r18, r24
     a7e:	2f 5f       	subi	r18, 0xFF	; 255
     a80:	3f 4f       	sbci	r19, 0xFF	; 255
     a82:	15 96       	adiw	r26, 0x05	; 5
     a84:	3c 93       	st	X, r19
     a86:	2e 93       	st	-X, r18
     a88:	14 97       	sbiw	r26, 0x04	; 4
     a8a:	ec 01       	movw	r28, r24
     a8c:	28 81       	ld	r18, Y

    #if FILTER_CUTOFF == 600
        afsk->iirX[1] = ((int8_t)fifo_pop(&afsk->delayFifo) * currentSample) >> 2;
     a8e:	26 02       	muls	r18, r22
     a90:	90 01       	movw	r18, r0
     a92:	11 24       	eor	r1, r1
     a94:	c9 01       	movw	r24, r18
     a96:	95 95       	asr	r25
     a98:	87 95       	ror	r24
     a9a:	95 95       	asr	r25
     a9c:	87 95       	ror	r24
     a9e:	e8 01       	movw	r28, r16
     aa0:	99 83       	std	Y+1, r25	; 0x01
     aa2:	88 83       	st	Y, r24
        // afsk->iirX[1] = ((int8_t)fifo_pop(&afsk->delayFifo) * currentSample) / 1.881349100;
    #else
        #error Unsupported filter cutoff!
    #endif

    afsk->iirY[0] = afsk->iirY[1];
     aa4:	7f 01       	movw	r14, r30
     aa6:	d3 ec       	ldi	r29, 0xC3	; 195
     aa8:	ed 0e       	add	r14, r29
     aaa:	f1 1c       	adc	r15, r1
     aac:	e7 01       	movw	r28, r14
     aae:	28 81       	ld	r18, Y
     ab0:	39 81       	ldd	r19, Y+1	; 0x01
     ab2:	8f 01       	movw	r16, r30
     ab4:	0f 53       	subi	r16, 0x3F	; 63
     ab6:	1f 4f       	sbci	r17, 0xFF	; 255
     ab8:	e8 01       	movw	r28, r16
     aba:	39 83       	std	Y+1, r19	; 0x01
     abc:	28 83       	st	Y, r18
    
    #if FILTER_CUTOFF == 600
        afsk->iirY[1] = afsk->iirX[0] + afsk->iirX[1] + (afsk->iirY[0] >> 1);
     abe:	84 0f       	add	r24, r20
     ac0:	95 1f       	adc	r25, r21
     ac2:	35 95       	asr	r19
     ac4:	27 95       	ror	r18
     ac6:	82 0f       	add	r24, r18
     ac8:	93 1f       	adc	r25, r19
     aca:	e7 01       	movw	r28, r14
     acc:	99 83       	std	Y+1, r25	; 0x01
     ace:	88 83       	st	Y, r24

    // We put the sampled bit in a delay-line:
    // First we bitshift everything 1 left
    afsk->sampledBits <<= 1;
    // And then add the sampled bit to our delay line
    afsk->sampledBits |= (afsk->iirY[1] > 0) ? 1 : 0;
     ad0:	af 01       	movw	r20, r30
     ad2:	4b 53       	subi	r20, 0x3B	; 59
     ad4:	5f 4f       	sbci	r21, 0xFF	; 255
     ad6:	21 e0       	ldi	r18, 0x01	; 1
     ad8:	18 16       	cp	r1, r24
     ada:	19 06       	cpc	r1, r25
     adc:	0c f0       	brlt	.+2      	; 0xae0 <AFSK_adc_isr+0xb2>
     ade:	20 e0       	ldi	r18, 0x00	; 0
    #endif


    // We put the sampled bit in a delay-line:
    // First we bitshift everything 1 left
    afsk->sampledBits <<= 1;
     ae0:	ea 01       	movw	r28, r20
     ae2:	88 81       	ld	r24, Y
     ae4:	88 0f       	add	r24, r24
    // And then add the sampled bit to our delay line
    afsk->sampledBits |= (afsk->iirY[1] > 0) ? 1 : 0;
     ae6:	82 2b       	or	r24, r18
     ae8:	88 83       	st	Y, r24
inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     aea:	16 96       	adiw	r26, 0x06	; 6
     aec:	8d 91       	ld	r24, X+
     aee:	9c 91       	ld	r25, X
     af0:	17 97       	sbiw	r26, 0x07	; 7
     af2:	ec 01       	movw	r28, r24
     af4:	68 83       	st	Y, r22
  
  if (f->tail == f->end) {
     af6:	16 96       	adiw	r26, 0x06	; 6
     af8:	2d 91       	ld	r18, X+
     afa:	3c 91       	ld	r19, X
     afc:	17 97       	sbiw	r26, 0x07	; 7
     afe:	12 96       	adiw	r26, 0x02	; 2
     b00:	8d 91       	ld	r24, X+
     b02:	9c 91       	ld	r25, X
     b04:	13 97       	sbiw	r26, 0x03	; 3
     b06:	28 17       	cp	r18, r24
     b08:	39 07       	cpc	r19, r25
     b0a:	21 f4       	brne	.+8      	; 0xb14 <AFSK_adc_isr+0xe6>
    f->tail = f->begin;
     b0c:	8d 91       	ld	r24, X+
     b0e:	9c 91       	ld	r25, X
     b10:	11 97       	sbiw	r26, 0x01	; 1
     b12:	05 c0       	rjmp	.+10     	; 0xb1e <AFSK_adc_isr+0xf0>
  } else {
    f->tail++;
     b14:	16 96       	adiw	r26, 0x06	; 6
     b16:	8d 91       	ld	r24, X+
     b18:	9c 91       	ld	r25, X
     b1a:	17 97       	sbiw	r26, 0x07	; 7
     b1c:	01 96       	adiw	r24, 0x01	; 1
     b1e:	17 96       	adiw	r26, 0x07	; 7
     b20:	9c 93       	st	X, r25
     b22:	8e 93       	st	-X, r24
     b24:	16 97       	sbiw	r26, 0x06	; 6
    // than half of PHASE_MAX, we move it forward a little.
    // This way, our "window" is constantly seeking to position
    // it's center at the bit transitions. Thus, we synchronise
    // our timing to the transmitter, even if it's timing is
    // a little off compared to our own.
    if (SIGNAL_TRANSITIONED(afsk->sampledBits)) {
     b26:	da 01       	movw	r26, r20
     b28:	9c 91       	ld	r25, X
     b2a:	89 2f       	mov	r24, r25
     b2c:	86 95       	lsr	r24
     b2e:	86 95       	lsr	r24
     b30:	89 27       	eor	r24, r25
     b32:	83 70       	andi	r24, 0x03	; 3
     b34:	df 01       	movw	r26, r30
     b36:	aa 53       	subi	r26, 0x3A	; 58
     b38:	bf 4f       	sbci	r27, 0xFF	; 255
     b3a:	83 30       	cpi	r24, 0x03	; 3
     b3c:	39 f4       	brne	.+14     	; 0xb4c <AFSK_adc_isr+0x11e>
        if (afsk->currentPhase < PHASE_THRESHOLD) {
     b3e:	8c 91       	ld	r24, X
     b40:	80 32       	cpi	r24, 0x20	; 32
     b42:	14 f4       	brge	.+4      	; 0xb48 <AFSK_adc_isr+0x11a>
            afsk->currentPhase += PHASE_INC;
     b44:	8f 5f       	subi	r24, 0xFF	; 255
     b46:	01 c0       	rjmp	.+2      	; 0xb4a <AFSK_adc_isr+0x11c>
        } else {
            afsk->currentPhase -= PHASE_INC;
     b48:	81 50       	subi	r24, 0x01	; 1
     b4a:	8c 93       	st	X, r24
        }
    }

    // We increment our phase counter
    afsk->currentPhase += PHASE_BITS;
     b4c:	8c 91       	ld	r24, X
     b4e:	88 5f       	subi	r24, 0xF8	; 248

    // Check if we have reached the end of
    // our sampling window.
    if (afsk->currentPhase >= PHASE_MAX) {
     b50:	80 34       	cpi	r24, 0x40	; 64
     b52:	14 f4       	brge	.+4      	; 0xb58 <AFSK_adc_isr+0x12a>
            afsk->currentPhase -= PHASE_INC;
        }
    }

    // We increment our phase counter
    afsk->currentPhase += PHASE_BITS;
     b54:	8c 93       	st	X, r24
     b56:	45 c1       	rjmp	.+650    	; 0xde2 <AFSK_adc_isr+0x3b4>
    // Check if we have reached the end of
    // our sampling window.
    if (afsk->currentPhase >= PHASE_MAX) {
        // If we have, wrap around our phase
        // counter by modulus
        afsk->currentPhase %= PHASE_MAX;
     b58:	8f 73       	andi	r24, 0x3F	; 63
     b5a:	8c 93       	st	X, r24

        // Bitshift to make room for the next
        // bit in our stream of demodulated bits
        afsk->actualBits <<= 1;
     b5c:	df 01       	movw	r26, r30
     b5e:	a9 53       	subi	r26, 0x39	; 57
     b60:	bf 4f       	sbci	r27, 0xFF	; 255
     b62:	8c 91       	ld	r24, X
     b64:	88 0f       	add	r24, r24

        // We determine the actual bit value by reading
        // the last 3 sampled bits. If there is three or
        // more 1's, we will assume that the transmitter
        // sent us a one, otherwise we assume a zero
        uint8_t bits = afsk->sampledBits & 0x07;
     b66:	97 70       	andi	r25, 0x07	; 7
        if (bits == 0x07 || // 111
            bits == 0x06 || // 110
     b68:	2b ef       	ldi	r18, 0xFB	; 251
     b6a:	29 0f       	add	r18, r25
        // We determine the actual bit value by reading
        // the last 3 sampled bits. If there is three or
        // more 1's, we will assume that the transmitter
        // sent us a one, otherwise we assume a zero
        uint8_t bits = afsk->sampledBits & 0x07;
        if (bits == 0x07 || // 111
     b6c:	23 30       	cpi	r18, 0x03	; 3
     b6e:	10 f0       	brcs	.+4      	; 0xb74 <AFSK_adc_isr+0x146>
            bits == 0x06 || // 110
            bits == 0x05 || // 101
     b70:	93 30       	cpi	r25, 0x03	; 3
     b72:	09 f4       	brne	.+2      	; 0xb76 <AFSK_adc_isr+0x148>
            bits == 0x03    // 011
            ) {
            afsk->actualBits |= 1;
     b74:	81 60       	ori	r24, 0x01	; 1
     b76:	8c 93       	st	X, r24
        // that we can use to synchronize our phase.
        //
        // We also check the return of the Link Control parser
        // to check if an error occured.

        if (!hdlcParse(&afsk->hdlc, !TRANSITION_FOUND(afsk->actualBits), &afsk->rxFifo)) {
     b78:	8c 91       	ld	r24, X
     b7a:	98 2f       	mov	r25, r24
     b7c:	96 95       	lsr	r25
     b7e:	89 27       	eor	r24, r25
     b80:	80 95       	com	r24
     b82:	81 70       	andi	r24, 0x01	; 1
    bool ret = true;

    // Bitshift our byte of demodulated bits to
    // the left by one bit, to make room for the
    // next incoming bit
    hdlc->demodulatedBits <<= 1;
     b84:	96 85       	ldd	r25, Z+14	; 0x0e
     b86:	99 0f       	add	r25, r25
    // And then put the newest bit from the 
    // demodulator into the byte.
    hdlc->demodulatedBits |= bit ? 1 : 0;
     b88:	89 2b       	or	r24, r25
     b8a:	86 87       	std	Z+14, r24	; 0x0e

    // Now we'll look at the last 8 received bits, and
    // check if we have received a HDLC flag (01111110)
    if (hdlc->demodulatedBits == HDLC_FLAG) {
     b8c:	8e 37       	cpi	r24, 0x7E	; 126
     b8e:	09 f0       	breq	.+2      	; 0xb92 <AFSK_adc_isr+0x164>
     b90:	47 c0       	rjmp	.+142    	; 0xc20 <AFSK_adc_isr+0x1f2>
inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
}

inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
     b92:	df 01       	movw	r26, r30
     b94:	ab 58       	subi	r26, 0x8B	; 139
     b96:	bf 4f       	sbci	r27, 0xFF	; 255
     b98:	14 96       	adiw	r26, 0x04	; 4
     b9a:	2d 91       	ld	r18, X+
     b9c:	3c 91       	ld	r19, X
     b9e:	15 97       	sbiw	r26, 0x05	; 5
     ba0:	8d 91       	ld	r24, X+
     ba2:	9c 91       	ld	r25, X
     ba4:	11 97       	sbiw	r26, 0x01	; 1
     ba6:	28 17       	cp	r18, r24
     ba8:	39 07       	cpc	r19, r25
     baa:	61 f4       	brne	.+24     	; 0xbc4 <AFSK_adc_isr+0x196>
     bac:	16 96       	adiw	r26, 0x06	; 6
     bae:	2d 91       	ld	r18, X+
     bb0:	3c 91       	ld	r19, X
     bb2:	17 97       	sbiw	r26, 0x07	; 7
     bb4:	12 96       	adiw	r26, 0x02	; 2
     bb6:	8d 91       	ld	r24, X+
     bb8:	9c 91       	ld	r25, X
     bba:	13 97       	sbiw	r26, 0x03	; 3
     bbc:	28 17       	cp	r18, r24
     bbe:	39 07       	cpc	r19, r25
     bc0:	09 f4       	brne	.+2      	; 0xbc4 <AFSK_adc_isr+0x196>
     bc2:	db c0       	rjmp	.+438    	; 0xd7a <AFSK_adc_isr+0x34c>
     bc4:	16 96       	adiw	r26, 0x06	; 6
     bc6:	2d 91       	ld	r18, X+
     bc8:	3c 91       	ld	r19, X
     bca:	17 97       	sbiw	r26, 0x07	; 7
     bcc:	14 96       	adiw	r26, 0x04	; 4
     bce:	8d 91       	ld	r24, X+
     bd0:	9c 91       	ld	r25, X
     bd2:	15 97       	sbiw	r26, 0x05	; 5
     bd4:	01 97       	sbiw	r24, 0x01	; 1
        // If we have, check that our output buffer is
        // not full.
        if (!fifo_isfull(fifo)) {
     bd6:	28 17       	cp	r18, r24
     bd8:	39 07       	cpc	r19, r25
     bda:	09 f4       	brne	.+2      	; 0xbde <AFSK_adc_isr+0x1b0>
     bdc:	ce c0       	rjmp	.+412    	; 0xd7a <AFSK_adc_isr+0x34c>
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     bde:	16 96       	adiw	r26, 0x06	; 6
     be0:	cd 91       	ld	r28, X+
     be2:	dc 91       	ld	r29, X
     be4:	17 97       	sbiw	r26, 0x07	; 7
     be6:	8e e7       	ldi	r24, 0x7E	; 126
     be8:	88 83       	st	Y, r24
  
  if (f->tail == f->end) {
     bea:	16 96       	adiw	r26, 0x06	; 6
     bec:	2d 91       	ld	r18, X+
     bee:	3c 91       	ld	r19, X
     bf0:	17 97       	sbiw	r26, 0x07	; 7
     bf2:	12 96       	adiw	r26, 0x02	; 2
     bf4:	8d 91       	ld	r24, X+
     bf6:	9c 91       	ld	r25, X
     bf8:	13 97       	sbiw	r26, 0x03	; 3
     bfa:	28 17       	cp	r18, r24
     bfc:	39 07       	cpc	r19, r25
     bfe:	21 f4       	brne	.+8      	; 0xc08 <AFSK_adc_isr+0x1da>
    f->tail = f->begin;
     c00:	8d 91       	ld	r24, X+
     c02:	9c 91       	ld	r25, X
     c04:	11 97       	sbiw	r26, 0x01	; 1
     c06:	05 c0       	rjmp	.+10     	; 0xc12 <AFSK_adc_isr+0x1e4>
  } else {
    f->tail++;
     c08:	16 96       	adiw	r26, 0x06	; 6
     c0a:	8d 91       	ld	r24, X+
     c0c:	9c 91       	ld	r25, X
     c0e:	17 97       	sbiw	r26, 0x07	; 7
     c10:	01 96       	adiw	r24, 0x01	; 1
     c12:	17 96       	adiw	r26, 0x07	; 7
     c14:	9c 93       	st	X, r25
     c16:	8e 93       	st	-X, r24
     c18:	16 97       	sbiw	r26, 0x06	; 6
            // If it isn't, we'll push the HDLC_FLAG into
            // the buffer and indicate that we are now
            // receiving data. For bling we also turn
            // on the RX LED.
            fifo_push(fifo, HDLC_FLAG);
            hdlc->receiving = true;
     c1a:	81 e0       	ldi	r24, 0x01	; 1
     c1c:	81 8b       	std	Z+17, r24	; 0x11
     c1e:	b0 c0       	rjmp	.+352    	; 0xd80 <AFSK_adc_isr+0x352>
    // (or silence) is taking place, and the demodulator
    // returns an endless stream of zeroes. Due to the NRZ
    // coding, the actual bits send to this function will
    // be an endless stream of ones, which this AND operation
    // will also detect.
    if ((hdlc->demodulatedBits & HDLC_RESET) == HDLC_RESET) {
     c20:	98 2f       	mov	r25, r24
     c22:	9f 77       	andi	r25, 0x7F	; 127
     c24:	9f 37       	cpi	r25, 0x7F	; 127
     c26:	19 f4       	brne	.+6      	; 0xc2e <AFSK_adc_isr+0x200>
        // If we have, something probably went wrong at the
        // transmitting end, and we abort the reception.
        hdlc->receiving = false;
     c28:	11 8a       	std	Z+17, r1	; 0x11
        LED_RX_OFF();
     c2a:	2a 98       	cbi	0x05, 2	; 5
     c2c:	da c0       	rjmp	.+436    	; 0xde2 <AFSK_adc_isr+0x3b4>
    }

    // If we have not yet seen a HDLC_FLAG indicating that
    // a transmission is actually taking place, don't bother
    // with anything.
    if (!hdlc->receiving)
     c2e:	91 89       	ldd	r25, Z+17	; 0x11
     c30:	99 23       	and	r25, r25
     c32:	09 f4       	brne	.+2      	; 0xc36 <AFSK_adc_isr+0x208>
     c34:	d6 c0       	rjmp	.+428    	; 0xde2 <AFSK_adc_isr+0x3b4>
    // 
    // We do the detection by applying an AND bit-mask to the
    // stream of demodulated bits. This mask is 00111111 (0x3f)
    // if the result of the operation is 00111110 (0x3e), we
    // have detected a stuffed bit.
    if ((hdlc->demodulatedBits & 0x3f) == 0x3e)
     c36:	98 2f       	mov	r25, r24
     c38:	9f 73       	andi	r25, 0x3F	; 63
     c3a:	9e 33       	cpi	r25, 0x3E	; 62
     c3c:	09 f4       	brne	.+2      	; 0xc40 <AFSK_adc_isr+0x212>
     c3e:	d1 c0       	rjmp	.+418    	; 0xde2 <AFSK_adc_isr+0x3b4>
        return ret;

    // If we have an actual 1 bit, push this to the current byte
    // If it's a zero, we don't need to do anything, since the
    // bit is initialized to zero when we bitshifted earlier.
    if (hdlc->demodulatedBits & 0x01)
     c40:	80 ff       	sbrs	r24, 0
     c42:	03 c0       	rjmp	.+6      	; 0xc4a <AFSK_adc_isr+0x21c>
        hdlc->currentByte |= 0x80;
     c44:	80 89       	ldd	r24, Z+16	; 0x10
     c46:	80 68       	ori	r24, 0x80	; 128
     c48:	80 8b       	std	Z+16, r24	; 0x10

    // Increment the bitIndex and check if we have a complete byte
    if (++hdlc->bitIndex >= 8) {
     c4a:	97 85       	ldd	r25, Z+15	; 0x0f
     c4c:	9f 5f       	subi	r25, 0xFF	; 255
     c4e:	97 87       	std	Z+15, r25	; 0x0f
     c50:	80 89       	ldd	r24, Z+16	; 0x10
     c52:	98 30       	cpi	r25, 0x08	; 8
     c54:	08 f4       	brcc	.+2      	; 0xc58 <AFSK_adc_isr+0x22a>
     c56:	99 c0       	rjmp	.+306    	; 0xd8a <AFSK_adc_isr+0x35c>
     c58:	df 01       	movw	r26, r30
     c5a:	ab 58       	subi	r26, 0x8B	; 139
     c5c:	bf 4f       	sbci	r27, 0xFF	; 255
        // of a bitstuffed byte that is equal to said control
        // character, but is actually part of the data stream.
        // By inserting the escape character, we tell the protocol
        // layer that this is not an actual control character, but
        // data.
        if ((hdlc->currentByte == HDLC_FLAG ||
     c5e:	92 e8       	ldi	r25, 0x82	; 130
     c60:	98 0f       	add	r25, r24
     c62:	92 30       	cpi	r25, 0x02	; 2
     c64:	18 f0       	brcs	.+6      	; 0xc6c <AFSK_adc_isr+0x23e>
             hdlc->currentByte == HDLC_RESET ||
     c66:	8b 31       	cpi	r24, 0x1B	; 27
     c68:	09 f0       	breq	.+2      	; 0xc6c <AFSK_adc_isr+0x23e>
     c6a:	44 c0       	rjmp	.+136    	; 0xcf4 <AFSK_adc_isr+0x2c6>
inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
}

inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
     c6c:	14 96       	adiw	r26, 0x04	; 4
     c6e:	2d 91       	ld	r18, X+
     c70:	3c 91       	ld	r19, X
     c72:	15 97       	sbiw	r26, 0x05	; 5
     c74:	8d 91       	ld	r24, X+
     c76:	9c 91       	ld	r25, X
     c78:	11 97       	sbiw	r26, 0x01	; 1
     c7a:	28 17       	cp	r18, r24
     c7c:	39 07       	cpc	r19, r25
     c7e:	59 f4       	brne	.+22     	; 0xc96 <AFSK_adc_isr+0x268>
     c80:	16 96       	adiw	r26, 0x06	; 6
     c82:	2d 91       	ld	r18, X+
     c84:	3c 91       	ld	r19, X
     c86:	17 97       	sbiw	r26, 0x07	; 7
     c88:	12 96       	adiw	r26, 0x02	; 2
     c8a:	8d 91       	ld	r24, X+
     c8c:	9c 91       	ld	r25, X
     c8e:	13 97       	sbiw	r26, 0x03	; 3
     c90:	28 17       	cp	r18, r24
     c92:	39 07       	cpc	r19, r25
     c94:	59 f1       	breq	.+86     	; 0xcec <AFSK_adc_isr+0x2be>
     c96:	16 96       	adiw	r26, 0x06	; 6
     c98:	2d 91       	ld	r18, X+
     c9a:	3c 91       	ld	r19, X
     c9c:	17 97       	sbiw	r26, 0x07	; 7
     c9e:	14 96       	adiw	r26, 0x04	; 4
     ca0:	8d 91       	ld	r24, X+
     ca2:	9c 91       	ld	r25, X
     ca4:	15 97       	sbiw	r26, 0x05	; 5
     ca6:	01 97       	sbiw	r24, 0x01	; 1
             hdlc->currentByte == AX25_ESC)) {
            // We also need to check that our received data buffer
            // is not full before putting more data in
            if (!fifo_isfull(fifo)) {
     ca8:	28 17       	cp	r18, r24
     caa:	39 07       	cpc	r19, r25
     cac:	f9 f0       	breq	.+62     	; 0xcec <AFSK_adc_isr+0x2be>
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     cae:	16 96       	adiw	r26, 0x06	; 6
     cb0:	cd 91       	ld	r28, X+
     cb2:	dc 91       	ld	r29, X
     cb4:	17 97       	sbiw	r26, 0x07	; 7
     cb6:	8b e1       	ldi	r24, 0x1B	; 27
     cb8:	88 83       	st	Y, r24
  
  if (f->tail == f->end) {
     cba:	16 96       	adiw	r26, 0x06	; 6
     cbc:	2d 91       	ld	r18, X+
     cbe:	3c 91       	ld	r19, X
     cc0:	17 97       	sbiw	r26, 0x07	; 7
     cc2:	12 96       	adiw	r26, 0x02	; 2
     cc4:	8d 91       	ld	r24, X+
     cc6:	9c 91       	ld	r25, X
     cc8:	13 97       	sbiw	r26, 0x03	; 3
     cca:	28 17       	cp	r18, r24
     ccc:	39 07       	cpc	r19, r25
     cce:	21 f4       	brne	.+8      	; 0xcd8 <AFSK_adc_isr+0x2aa>
    f->tail = f->begin;
     cd0:	8d 91       	ld	r24, X+
     cd2:	9c 91       	ld	r25, X
     cd4:	11 97       	sbiw	r26, 0x01	; 1
     cd6:	05 c0       	rjmp	.+10     	; 0xce2 <AFSK_adc_isr+0x2b4>
  } else {
    f->tail++;
     cd8:	16 96       	adiw	r26, 0x06	; 6
     cda:	8d 91       	ld	r24, X+
     cdc:	9c 91       	ld	r25, X
     cde:	17 97       	sbiw	r26, 0x07	; 7
     ce0:	01 96       	adiw	r24, 0x01	; 1
     ce2:	17 96       	adiw	r26, 0x07	; 7
     ce4:	9c 93       	st	X, r25
     ce6:	8e 93       	st	-X, r24
     ce8:	16 97       	sbiw	r26, 0x06	; 6
     cea:	04 c0       	rjmp	.+8      	; 0xcf4 <AFSK_adc_isr+0x2c6>
                fifo_push(fifo, AX25_ESC);
            } else {
                // If it is, abort and return false
                hdlc->receiving = false;
     cec:	11 8a       	std	Z+17, r1	; 0x11
                LED_RX_OFF();
     cee:	2a 98       	cbi	0x05, 2	; 5
                ret = false;
     cf0:	80 e0       	ldi	r24, 0x00	; 0
     cf2:	01 c0       	rjmp	.+2      	; 0xcf6 <AFSK_adc_isr+0x2c8>
}

static bool hdlcParse(Hdlc *hdlc, bool bit, FIFOBuffer *fifo) {
    // Initialise a return value. We start with the
    // assumption that all is going to end well :)
    bool ret = true;
     cf4:	81 e0       	ldi	r24, 0x01	; 1
inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
}

inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
     cf6:	14 96       	adiw	r26, 0x04	; 4
     cf8:	4d 91       	ld	r20, X+
     cfa:	5c 91       	ld	r21, X
     cfc:	15 97       	sbiw	r26, 0x05	; 5
     cfe:	2d 91       	ld	r18, X+
     d00:	3c 91       	ld	r19, X
     d02:	11 97       	sbiw	r26, 0x01	; 1
     d04:	42 17       	cp	r20, r18
     d06:	53 07       	cpc	r21, r19
     d08:	59 f4       	brne	.+22     	; 0xd20 <AFSK_adc_isr+0x2f2>
     d0a:	16 96       	adiw	r26, 0x06	; 6
     d0c:	4d 91       	ld	r20, X+
     d0e:	5c 91       	ld	r21, X
     d10:	17 97       	sbiw	r26, 0x07	; 7
     d12:	12 96       	adiw	r26, 0x02	; 2
     d14:	2d 91       	ld	r18, X+
     d16:	3c 91       	ld	r19, X
     d18:	13 97       	sbiw	r26, 0x03	; 3
     d1a:	42 17       	cp	r20, r18
     d1c:	53 07       	cpc	r21, r19
     d1e:	69 f1       	breq	.+90     	; 0xd7a <AFSK_adc_isr+0x34c>
     d20:	16 96       	adiw	r26, 0x06	; 6
     d22:	4d 91       	ld	r20, X+
     d24:	5c 91       	ld	r21, X
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	14 96       	adiw	r26, 0x04	; 4
     d2a:	2d 91       	ld	r18, X+
     d2c:	3c 91       	ld	r19, X
     d2e:	15 97       	sbiw	r26, 0x05	; 5
     d30:	21 50       	subi	r18, 0x01	; 1
     d32:	31 09       	sbc	r19, r1
            }
        }

        // Push the actual byte to the received data FIFO,
        // if it isn't full.
        if (!fifo_isfull(fifo)) {
     d34:	42 17       	cp	r20, r18
     d36:	53 07       	cpc	r21, r19
     d38:	01 f1       	breq	.+64     	; 0xd7a <AFSK_adc_isr+0x34c>
            fifo_push(fifo, hdlc->currentByte);
     d3a:	90 89       	ldd	r25, Z+16	; 0x10
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     d3c:	16 96       	adiw	r26, 0x06	; 6
     d3e:	cd 91       	ld	r28, X+
     d40:	dc 91       	ld	r29, X
     d42:	17 97       	sbiw	r26, 0x07	; 7
     d44:	98 83       	st	Y, r25
  
  if (f->tail == f->end) {
     d46:	16 96       	adiw	r26, 0x06	; 6
     d48:	4d 91       	ld	r20, X+
     d4a:	5c 91       	ld	r21, X
     d4c:	17 97       	sbiw	r26, 0x07	; 7
     d4e:	12 96       	adiw	r26, 0x02	; 2
     d50:	2d 91       	ld	r18, X+
     d52:	3c 91       	ld	r19, X
     d54:	13 97       	sbiw	r26, 0x03	; 3
     d56:	42 17       	cp	r20, r18
     d58:	53 07       	cpc	r21, r19
     d5a:	21 f4       	brne	.+8      	; 0xd64 <AFSK_adc_isr+0x336>
    f->tail = f->begin;
     d5c:	2d 91       	ld	r18, X+
     d5e:	3c 91       	ld	r19, X
     d60:	11 97       	sbiw	r26, 0x01	; 1
     d62:	06 c0       	rjmp	.+12     	; 0xd70 <AFSK_adc_isr+0x342>
  } else {
    f->tail++;
     d64:	16 96       	adiw	r26, 0x06	; 6
     d66:	2d 91       	ld	r18, X+
     d68:	3c 91       	ld	r19, X
     d6a:	17 97       	sbiw	r26, 0x07	; 7
     d6c:	2f 5f       	subi	r18, 0xFF	; 255
     d6e:	3f 4f       	sbci	r19, 0xFF	; 255
     d70:	17 96       	adiw	r26, 0x07	; 7
     d72:	3c 93       	st	X, r19
     d74:	2e 93       	st	-X, r18
     d76:	16 97       	sbiw	r26, 0x06	; 6
     d78:	03 c0       	rjmp	.+6      	; 0xd80 <AFSK_adc_isr+0x352>
        } else {
            // If it is, well, you know by now!
            hdlc->receiving = false;
     d7a:	11 8a       	std	Z+17, r1	; 0x11
            LED_RX_OFF();
     d7c:	2a 98       	cbi	0x05, 2	; 5
            ret = false;
     d7e:	80 e0       	ldi	r24, 0x00	; 0
        }

        // Wipe received byte and reset bit index to 0
        hdlc->currentByte = 0;
     d80:	10 8a       	std	Z+16, r1	; 0x10
        hdlc->bitIndex = 0;
     d82:	17 86       	std	Z+15, r1	; 0x0f
        // that we can use to synchronize our phase.
        //
        // We also check the return of the Link Control parser
        // to check if an error occured.

        if (!hdlcParse(&afsk->hdlc, !TRANSITION_FOUND(afsk->actualBits), &afsk->rxFifo)) {
     d84:	88 23       	and	r24, r24
     d86:	21 f0       	breq	.+8      	; 0xd90 <AFSK_adc_isr+0x362>
     d88:	2c c0       	rjmp	.+88     	; 0xde2 <AFSK_adc_isr+0x3b4>
        hdlc->bitIndex = 0;

    } else {
        // We don't have a full byte yet, bitshift the byte
        // to make room for the next bit
        hdlc->currentByte >>= 1;
     d8a:	86 95       	lsr	r24
     d8c:	80 8b       	std	Z+16, r24	; 0x10
     d8e:	29 c0       	rjmp	.+82     	; 0xde2 <AFSK_adc_isr+0x3b4>
        //
        // We also check the return of the Link Control parser
        // to check if an error occured.

        if (!hdlcParse(&afsk->hdlc, !TRANSITION_FOUND(afsk->actualBits), &afsk->rxFifo)) {
            afsk->status |= 1;
     d90:	df 01       	movw	r26, r30
     d92:	a8 53       	subi	r26, 0x38	; 56
     d94:	bf 4f       	sbci	r27, 0xFF	; 255
     d96:	8d 91       	ld	r24, X+
     d98:	9c 91       	ld	r25, X
     d9a:	11 97       	sbiw	r26, 0x01	; 1
     d9c:	81 60       	ori	r24, 0x01	; 1
     d9e:	11 96       	adiw	r26, 0x01	; 1
     da0:	9c 93       	st	X, r25
     da2:	8e 93       	st	-X, r24
inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
}

inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
     da4:	eb 58       	subi	r30, 0x8B	; 139
     da6:	ff 4f       	sbci	r31, 0xFF	; 255
     da8:	24 81       	ldd	r18, Z+4	; 0x04
     daa:	35 81       	ldd	r19, Z+5	; 0x05
     dac:	80 81       	ld	r24, Z
     dae:	91 81       	ldd	r25, Z+1	; 0x01
     db0:	28 17       	cp	r18, r24
     db2:	39 07       	cpc	r19, r25
     db4:	39 f4       	brne	.+14     	; 0xdc4 <AFSK_adc_isr+0x396>
     db6:	26 81       	ldd	r18, Z+6	; 0x06
     db8:	37 81       	ldd	r19, Z+7	; 0x07
     dba:	82 81       	ldd	r24, Z+2	; 0x02
     dbc:	93 81       	ldd	r25, Z+3	; 0x03
     dbe:	28 17       	cp	r18, r24
     dc0:	39 07       	cpc	r19, r25
     dc2:	41 f0       	breq	.+16     	; 0xdd4 <AFSK_adc_isr+0x3a6>
     dc4:	26 81       	ldd	r18, Z+6	; 0x06
     dc6:	37 81       	ldd	r19, Z+7	; 0x07
     dc8:	84 81       	ldd	r24, Z+4	; 0x04
     dca:	95 81       	ldd	r25, Z+5	; 0x05
     dcc:	01 97       	sbiw	r24, 0x01	; 1
            if (fifo_isfull(&afsk->rxFifo)) {
     dce:	28 17       	cp	r18, r24
     dd0:	39 07       	cpc	r19, r25
     dd2:	39 f4       	brne	.+14     	; 0xde2 <AFSK_adc_isr+0x3b4>
    return *(f->head++);
  }
}

inline void fifo_flush(FIFOBuffer *f) {
  f->head = f->tail;
     dd4:	86 81       	ldd	r24, Z+6	; 0x06
     dd6:	97 81       	ldd	r25, Z+7	; 0x07
     dd8:	95 83       	std	Z+5, r25	; 0x05
     dda:	84 83       	std	Z+4, r24	; 0x04
                fifo_flush(&afsk->rxFifo);
                afsk->status = 0;
     ddc:	11 96       	adiw	r26, 0x01	; 1
     dde:	1c 92       	st	X, r1
     de0:	1e 92       	st	-X, r1
            }
        }
    }

}
     de2:	df 91       	pop	r29
     de4:	cf 91       	pop	r28
     de6:	1f 91       	pop	r17
     de8:	0f 91       	pop	r16
     dea:	ff 90       	pop	r15
     dec:	ef 90       	pop	r14
     dee:	08 95       	ret

00000df0 <__vector_21>:


ISR(ADC_vect) {
     df0:	1f 92       	push	r1
     df2:	0f 92       	push	r0
     df4:	0f b6       	in	r0, 0x3f	; 63
     df6:	0f 92       	push	r0
     df8:	11 24       	eor	r1, r1
     dfa:	2f 93       	push	r18
     dfc:	3f 93       	push	r19
     dfe:	4f 93       	push	r20
     e00:	5f 93       	push	r21
     e02:	6f 93       	push	r22
     e04:	7f 93       	push	r23
     e06:	8f 93       	push	r24
     e08:	9f 93       	push	r25
     e0a:	af 93       	push	r26
     e0c:	bf 93       	push	r27
     e0e:	ef 93       	push	r30
     e10:	ff 93       	push	r31
    TIFR1 = _BV(ICF1);
     e12:	80 e2       	ldi	r24, 0x20	; 32
     e14:	86 bb       	out	0x16, r24	; 22
    AFSK_adc_isr(AFSK_modem, ((int16_t)((ADC) >> 2) - 128));
     e16:	60 91 78 00 	lds	r22, 0x0078
     e1a:	70 91 79 00 	lds	r23, 0x0079
     e1e:	76 95       	lsr	r23
     e20:	67 95       	ror	r22
     e22:	76 95       	lsr	r23
     e24:	67 95       	ror	r22
     e26:	60 58       	subi	r22, 0x80	; 128
     e28:	80 91 f3 03 	lds	r24, 0x03F3
     e2c:	90 91 f4 03 	lds	r25, 0x03F4
     e30:	0e 94 17 05 	call	0xa2e	; 0xa2e <AFSK_adc_isr>
    if (hw_afsk_dac_isr) {
     e34:	80 91 3d 01 	lds	r24, 0x013D
     e38:	88 23       	and	r24, r24
     e3a:	49 f0       	breq	.+18     	; 0xe4e <__vector_21+0x5e>
        DAC_PORT = (AFSK_dac_isr(AFSK_modem) & 0xF0) | _BV(3); 
     e3c:	80 91 f3 03 	lds	r24, 0x03F3
     e40:	90 91 f4 03 	lds	r25, 0x03F4
     e44:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <AFSK_dac_isr>
     e48:	80 7f       	andi	r24, 0xF0	; 240
     e4a:	88 60       	ori	r24, 0x08	; 8
     e4c:	01 c0       	rjmp	.+2      	; 0xe50 <__vector_21+0x60>
    } else {
        DAC_PORT = 128;
     e4e:	80 e8       	ldi	r24, 0x80	; 128
     e50:	8b b9       	out	0x0b, r24	; 11
    }
    ++_clock;
     e52:	80 91 0b 02 	lds	r24, 0x020B
     e56:	90 91 0c 02 	lds	r25, 0x020C
     e5a:	a0 91 0d 02 	lds	r26, 0x020D
     e5e:	b0 91 0e 02 	lds	r27, 0x020E
     e62:	01 96       	adiw	r24, 0x01	; 1
     e64:	a1 1d       	adc	r26, r1
     e66:	b1 1d       	adc	r27, r1
     e68:	80 93 0b 02 	sts	0x020B, r24
     e6c:	90 93 0c 02 	sts	0x020C, r25
     e70:	a0 93 0d 02 	sts	0x020D, r26
     e74:	b0 93 0e 02 	sts	0x020E, r27
     e78:	ff 91       	pop	r31
     e7a:	ef 91       	pop	r30
     e7c:	bf 91       	pop	r27
     e7e:	af 91       	pop	r26
     e80:	9f 91       	pop	r25
     e82:	8f 91       	pop	r24
     e84:	7f 91       	pop	r23
     e86:	6f 91       	pop	r22
     e88:	5f 91       	pop	r21
     e8a:	4f 91       	pop	r20
     e8c:	3f 91       	pop	r19
     e8e:	2f 91       	pop	r18
     e90:	0f 90       	pop	r0
     e92:	0f be       	out	0x3f, r0	; 63
     e94:	0f 90       	pop	r0
     e96:	1f 90       	pop	r1
     e98:	18 95       	reti

00000e9a <ax25_putchar>:
        ctx->escape = false;
    }
}

static void ax25_putchar(AX25Ctx *ctx, uint8_t c)
{
     e9a:	cf 92       	push	r12
     e9c:	df 92       	push	r13
     e9e:	ef 92       	push	r14
     ea0:	ff 92       	push	r15
     ea2:	0f 93       	push	r16
     ea4:	1f 93       	push	r17
     ea6:	cf 93       	push	r28
     ea8:	df 93       	push	r29
     eaa:	1f 92       	push	r1
     eac:	cd b7       	in	r28, 0x3d	; 61
     eae:	de b7       	in	r29, 0x3e	; 62
     eb0:	7c 01       	movw	r14, r24
     eb2:	26 2f       	mov	r18, r22
    if (c == HDLC_FLAG || c == HDLC_RESET || c == AX25_ESC) fputc(AX25_ESC, ctx->ch);
     eb4:	82 e8       	ldi	r24, 0x82	; 130
     eb6:	86 0f       	add	r24, r22
     eb8:	87 01       	movw	r16, r14
     eba:	06 5b       	subi	r16, 0xB6	; 182
     ebc:	1e 4f       	sbci	r17, 0xFE	; 254
     ebe:	82 30       	cpi	r24, 0x02	; 2
     ec0:	10 f0       	brcs	.+4      	; 0xec6 <ax25_putchar+0x2c>
     ec2:	6b 31       	cpi	r22, 0x1B	; 27
     ec4:	49 f4       	brne	.+18     	; 0xed8 <ax25_putchar+0x3e>
     ec6:	f8 01       	movw	r30, r16
     ec8:	60 81       	ld	r22, Z
     eca:	71 81       	ldd	r23, Z+1	; 0x01
     ecc:	8b e1       	ldi	r24, 0x1B	; 27
     ece:	90 e0       	ldi	r25, 0x00	; 0
     ed0:	29 83       	std	Y+1, r18	; 0x01
     ed2:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
     ed6:	29 81       	ldd	r18, Y+1	; 0x01
    ctx->crc_out = update_crc_ccit(c, ctx->crc_out);
     ed8:	d7 01       	movw	r26, r14
     eda:	a0 5b       	subi	r26, 0xB0	; 176
     edc:	be 4f       	sbci	r27, 0xFE	; 254
     ede:	3c 91       	ld	r19, X
     ee0:	11 96       	adiw	r26, 0x01	; 1
     ee2:	4c 91       	ld	r20, X
     ee4:	11 97       	sbiw	r26, 0x01	; 1
#define CRC_CCIT_INIT_VAL ((uint16_t)0xFFFF)

extern const uint16_t crc_ccit_table[256];

inline uint16_t update_crc_ccit(uint8_t c, uint16_t prev_crc) {
    return (prev_crc >> 8) ^ pgm_read_word(&crc_ccit_table[(prev_crc ^ c) & 0xff]);
     ee6:	82 2f       	mov	r24, r18
     ee8:	90 e0       	ldi	r25, 0x00	; 0
     eea:	fc 01       	movw	r30, r24
     eec:	e3 27       	eor	r30, r19
     eee:	ee 0f       	add	r30, r30
     ef0:	ff 1f       	adc	r31, r31
     ef2:	e8 51       	subi	r30, 0x18	; 24
     ef4:	ff 4f       	sbci	r31, 0xFF	; 255
     ef6:	25 91       	lpm	r18, Z+
     ef8:	34 91       	lpm	r19, Z
     efa:	c4 2e       	mov	r12, r20
     efc:	d1 2c       	mov	r13, r1
     efe:	2c 25       	eor	r18, r12
     f00:	3d 25       	eor	r19, r13
     f02:	2d 93       	st	X+, r18
     f04:	3c 93       	st	X, r19
    fputc(c, ctx->ch);
     f06:	f8 01       	movw	r30, r16
     f08:	60 81       	ld	r22, Z
     f0a:	71 81       	ldd	r23, Z+1	; 0x01
}
     f0c:	0f 90       	pop	r0
     f0e:	df 91       	pop	r29
     f10:	cf 91       	pop	r28
     f12:	1f 91       	pop	r17
     f14:	0f 91       	pop	r16
     f16:	ff 90       	pop	r15
     f18:	ef 90       	pop	r14
     f1a:	df 90       	pop	r13
     f1c:	cf 90       	pop	r12

static void ax25_putchar(AX25Ctx *ctx, uint8_t c)
{
    if (c == HDLC_FLAG || c == HDLC_RESET || c == AX25_ESC) fputc(AX25_ESC, ctx->ch);
    ctx->crc_out = update_crc_ccit(c, ctx->crc_out);
    fputc(c, ctx->ch);
     f1e:	0c 94 cb 0e 	jmp	0x1d96	; 0x1d96 <fputc>

00000f22 <ax25_init>:
#define MIN(a,b) ({ typeof(a) _a = (a); typeof(b) _b = (b); ((typeof(_a))((_a < _b) ? _a : _b)); })
#define DECODE_CALL(buf, addr) for (unsigned i = 0; i < sizeof((addr)); i++) { char c = (*(buf)++ >> 1); (addr)[i] = (c == ' ') ? '\x0' : c; }
#define AX25_SET_REPEATED(msg, idx, val) do { if (val) { (msg)->rpt_flags |= _BV(idx); } else { (msg)->rpt_flags &= ~_BV(idx) ; } } while(0)

void ax25_init(AX25Ctx *ctx, FILE *channel, ax25_callback_t hook) {
    memset(ctx, 0, sizeof(*ctx));
     f22:	26 e5       	ldi	r18, 0x56	; 86
     f24:	31 e0       	ldi	r19, 0x01	; 1
     f26:	dc 01       	movw	r26, r24
     f28:	f9 01       	movw	r30, r18
     f2a:	1d 92       	st	X+, r1
     f2c:	31 97       	sbiw	r30, 0x01	; 1
     f2e:	e9 f7       	brne	.-6      	; 0xf2a <ax25_init+0x8>
    ctx->ch = channel;
     f30:	fc 01       	movw	r30, r24
     f32:	e6 5b       	subi	r30, 0xB6	; 182
     f34:	fe 4f       	sbci	r31, 0xFE	; 254
     f36:	71 83       	std	Z+1, r23	; 0x01
     f38:	60 83       	st	Z, r22
    ctx->hook = hook;
     f3a:	38 96       	adiw	r30, 0x08	; 8
     f3c:	51 83       	std	Z+1, r21	; 0x01
     f3e:	40 83       	st	Z, r20
    ctx->crc_in = ctx->crc_out = CRC_CCIT_INIT_VAL;
     f40:	32 97       	sbiw	r30, 0x02	; 2
     f42:	2f ef       	ldi	r18, 0xFF	; 255
     f44:	3f ef       	ldi	r19, 0xFF	; 255
     f46:	31 83       	std	Z+1, r19	; 0x01
     f48:	20 83       	st	Z, r18
     f4a:	32 97       	sbiw	r30, 0x02	; 2
     f4c:	31 83       	std	Z+1, r19	; 0x01
     f4e:	20 83       	st	Z, r18
     f50:	08 95       	ret

00000f52 <ax25_poll>:

static void ax25_decode(AX25Ctx *ctx) {
    if (ctx->hook) ctx->hook(ctx);
}

void ax25_poll(AX25Ctx *ctx) {
     f52:	3f 92       	push	r3
     f54:	4f 92       	push	r4
     f56:	5f 92       	push	r5
     f58:	6f 92       	push	r6
     f5a:	7f 92       	push	r7
     f5c:	8f 92       	push	r8
     f5e:	9f 92       	push	r9
     f60:	af 92       	push	r10
     f62:	bf 92       	push	r11
     f64:	cf 92       	push	r12
     f66:	df 92       	push	r13
     f68:	ef 92       	push	r14
     f6a:	ff 92       	push	r15
     f6c:	0f 93       	push	r16
     f6e:	1f 93       	push	r17
     f70:	cf 93       	push	r28
     f72:	df 93       	push	r29
     f74:	2c 01       	movw	r4, r24
    int c;
    
    while ((c = fgetc(ctx->ch)) != EOF) {
     f76:	3c 01       	movw	r6, r24
     f78:	26 eb       	ldi	r18, 0xB6	; 182
     f7a:	62 1a       	sub	r6, r18
     f7c:	2e ef       	ldi	r18, 0xFE	; 254
     f7e:	72 0a       	sbc	r7, r18
        if (!ctx->escape && c == HDLC_FLAG) {
     f80:	6c 01       	movw	r12, r24
     f82:	4b ea       	ldi	r20, 0xAB	; 171
     f84:	c4 1a       	sub	r12, r20
     f86:	4e ef       	ldi	r20, 0xFE	; 254
     f88:	d4 0a       	sbc	r13, r20
        if (!ctx->escape && c == AX25_ESC) {
            ctx->escape = true;
            continue;
        }

        if (ctx->sync) {
     f8a:	ec 01       	movw	r28, r24
     f8c:	cc 5a       	subi	r28, 0xAC	; 172
     f8e:	de 4f       	sbci	r29, 0xFE	; 254
            if (ctx->frame_len < AX25_MAX_FRAME_LEN) {
     f90:	8c 01       	movw	r16, r24
     f92:	04 5b       	subi	r16, 0xB4	; 180
     f94:	1e 4f       	sbci	r17, 0xFE	; 254
                ctx->buf[ctx->frame_len++] = c;
                ctx->crc_in = update_crc_ccit(c, ctx->crc_in);
     f96:	7c 01       	movw	r14, r24
     f98:	82 eb       	ldi	r24, 0xB2	; 178
     f9a:	e8 1a       	sub	r14, r24
     f9c:	8e ef       	ldi	r24, 0xFE	; 254
     f9e:	f8 0a       	sbc	r15, r24
            ctx->sync = false;
            continue;
        }

        if (!ctx->escape && c == AX25_ESC) {
            ctx->escape = true;
     fa0:	33 24       	eor	r3, r3
     fa2:	33 94       	inc	r3
                    #endif
                    ax25_decode(ctx);
                }
            }
            ctx->sync = true;
            ctx->crc_in = CRC_CCIT_INIT_VAL;
     fa4:	aa 24       	eor	r10, r10
     fa6:	aa 94       	dec	r10
     fa8:	ba 2c       	mov	r11, r10
    ctx->hook = hook;
    ctx->crc_in = ctx->crc_out = CRC_CCIT_INIT_VAL;
}

static void ax25_decode(AX25Ctx *ctx) {
    if (ctx->hook) ctx->hook(ctx);
     faa:	42 01       	movw	r8, r4
     fac:	ae ea       	ldi	r26, 0xAE	; 174
     fae:	8a 1a       	sub	r8, r26
     fb0:	ae ef       	ldi	r26, 0xFE	; 254
     fb2:	9a 0a       	sbc	r9, r26
}

void ax25_poll(AX25Ctx *ctx) {
    int c;
    
    while ((c = fgetc(ctx->ch)) != EOF) {
     fb4:	f3 01       	movw	r30, r6
     fb6:	80 81       	ld	r24, Z
     fb8:	91 81       	ldd	r25, Z+1	; 0x01
     fba:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <fgetc>
     fbe:	8f 3f       	cpi	r24, 0xFF	; 255
     fc0:	ff ef       	ldi	r31, 0xFF	; 255
     fc2:	9f 07       	cpc	r25, r31
     fc4:	09 f4       	brne	.+2      	; 0xfc8 <ax25_poll+0x76>
     fc6:	59 c0       	rjmp	.+178    	; 0x107a <ax25_poll+0x128>
        if (!ctx->escape && c == HDLC_FLAG) {
     fc8:	f6 01       	movw	r30, r12
     fca:	20 81       	ld	r18, Z
     fcc:	21 11       	cpse	r18, r1
     fce:	29 c0       	rjmp	.+82     	; 0x1022 <ax25_poll+0xd0>
     fd0:	8e 37       	cpi	r24, 0x7E	; 126
     fd2:	91 05       	cpc	r25, r1
     fd4:	d9 f4       	brne	.+54     	; 0x100c <ax25_poll+0xba>
            if (ctx->frame_len >= AX25_MIN_FRAME_LEN) {
     fd6:	d8 01       	movw	r26, r16
     fd8:	8d 91       	ld	r24, X+
     fda:	9c 91       	ld	r25, X
     fdc:	42 97       	sbiw	r24, 0x12	; 18
     fde:	70 f0       	brcs	.+28     	; 0xffc <ax25_poll+0xaa>
                if (ctx->crc_in == AX25_CRC_CORRECT) {
     fe0:	f7 01       	movw	r30, r14
     fe2:	80 81       	ld	r24, Z
     fe4:	91 81       	ldd	r25, Z+1	; 0x01
     fe6:	88 3b       	cpi	r24, 0xB8	; 184
     fe8:	90 4f       	sbci	r25, 0xF0	; 240
     fea:	41 f4       	brne	.+16     	; 0xffc <ax25_poll+0xaa>
                    #if OPEN_SQUELCH == true
                        LED_RX_ON();
     fec:	2a 9a       	sbi	0x05, 2	; 5
    ctx->hook = hook;
    ctx->crc_in = ctx->crc_out = CRC_CCIT_INIT_VAL;
}

static void ax25_decode(AX25Ctx *ctx) {
    if (ctx->hook) ctx->hook(ctx);
     fee:	d4 01       	movw	r26, r8
     ff0:	ed 91       	ld	r30, X+
     ff2:	fc 91       	ld	r31, X
     ff4:	30 97       	sbiw	r30, 0x00	; 0
     ff6:	11 f0       	breq	.+4      	; 0xffc <ax25_poll+0xaa>
     ff8:	c2 01       	movw	r24, r4
     ffa:	09 95       	icall
                        LED_RX_ON();
                    #endif
                    ax25_decode(ctx);
                }
            }
            ctx->sync = true;
     ffc:	38 82       	st	Y, r3
            ctx->crc_in = CRC_CCIT_INIT_VAL;
     ffe:	f7 01       	movw	r30, r14
    1000:	b1 82       	std	Z+1, r11	; 0x01
    1002:	a0 82       	st	Z, r10
            ctx->frame_len = 0;
    1004:	d8 01       	movw	r26, r16
    1006:	1d 92       	st	X+, r1
    1008:	1c 92       	st	X, r1
            continue;
    100a:	d4 cf       	rjmp	.-88     	; 0xfb4 <ax25_poll+0x62>
        }

        if (!ctx->escape && c == HDLC_RESET) {
    100c:	8f 37       	cpi	r24, 0x7F	; 127
    100e:	91 05       	cpc	r25, r1
    1010:	11 f4       	brne	.+4      	; 0x1016 <ax25_poll+0xc4>
            ctx->sync = false;
    1012:	18 82       	st	Y, r1
            continue;
    1014:	cf cf       	rjmp	.-98     	; 0xfb4 <ax25_poll+0x62>
        }

        if (!ctx->escape && c == AX25_ESC) {
    1016:	8b 31       	cpi	r24, 0x1B	; 27
    1018:	91 05       	cpc	r25, r1
    101a:	19 f4       	brne	.+6      	; 0x1022 <ax25_poll+0xd0>
            ctx->escape = true;
    101c:	f6 01       	movw	r30, r12
    101e:	30 82       	st	Z, r3
            continue;
    1020:	c9 cf       	rjmp	.-110    	; 0xfb4 <ax25_poll+0x62>
        }

        if (ctx->sync) {
    1022:	28 81       	ld	r18, Y
    1024:	22 23       	and	r18, r18
    1026:	31 f1       	breq	.+76     	; 0x1074 <ax25_poll+0x122>
            if (ctx->frame_len < AX25_MAX_FRAME_LEN) {
    1028:	d8 01       	movw	r26, r16
    102a:	2d 91       	ld	r18, X+
    102c:	3c 91       	ld	r19, X
    102e:	2a 34       	cpi	r18, 0x4A	; 74
    1030:	b1 e0       	ldi	r27, 0x01	; 1
    1032:	3b 07       	cpc	r19, r27
    1034:	f0 f4       	brcc	.+60     	; 0x1072 <ax25_poll+0x120>
                ctx->buf[ctx->frame_len++] = c;
    1036:	a9 01       	movw	r20, r18
    1038:	4f 5f       	subi	r20, 0xFF	; 255
    103a:	5f 4f       	sbci	r21, 0xFF	; 255
    103c:	f8 01       	movw	r30, r16
    103e:	51 83       	std	Z+1, r21	; 0x01
    1040:	40 83       	st	Z, r20
    1042:	f2 01       	movw	r30, r4
    1044:	e2 0f       	add	r30, r18
    1046:	f3 1f       	adc	r31, r19
    1048:	80 83       	st	Z, r24
                ctx->crc_in = update_crc_ccit(c, ctx->crc_in);
    104a:	d7 01       	movw	r26, r14
    104c:	2d 91       	ld	r18, X+
    104e:	3c 91       	ld	r19, X
    1050:	f9 01       	movw	r30, r18
    1052:	e8 27       	eor	r30, r24
    1054:	ff 27       	eor	r31, r31
    1056:	ee 0f       	add	r30, r30
    1058:	ff 1f       	adc	r31, r31
    105a:	e8 51       	subi	r30, 0x18	; 24
    105c:	ff 4f       	sbci	r31, 0xFF	; 255
    105e:	85 91       	lpm	r24, Z+
    1060:	94 91       	lpm	r25, Z
    1062:	23 2f       	mov	r18, r19
    1064:	33 27       	eor	r19, r19
    1066:	82 27       	eor	r24, r18
    1068:	93 27       	eor	r25, r19
    106a:	f7 01       	movw	r30, r14
    106c:	91 83       	std	Z+1, r25	; 0x01
    106e:	80 83       	st	Z, r24
    1070:	01 c0       	rjmp	.+2      	; 0x1074 <ax25_poll+0x122>
            } else {
                ctx->sync = false;
    1072:	18 82       	st	Y, r1
            }
        }
        ctx->escape = false;
    1074:	d6 01       	movw	r26, r12
    1076:	1c 92       	st	X, r1
    1078:	9d cf       	rjmp	.-198    	; 0xfb4 <ax25_poll+0x62>
    }
}
    107a:	df 91       	pop	r29
    107c:	cf 91       	pop	r28
    107e:	1f 91       	pop	r17
    1080:	0f 91       	pop	r16
    1082:	ff 90       	pop	r15
    1084:	ef 90       	pop	r14
    1086:	df 90       	pop	r13
    1088:	cf 90       	pop	r12
    108a:	bf 90       	pop	r11
    108c:	af 90       	pop	r10
    108e:	9f 90       	pop	r9
    1090:	8f 90       	pop	r8
    1092:	7f 90       	pop	r7
    1094:	6f 90       	pop	r6
    1096:	5f 90       	pop	r5
    1098:	4f 90       	pop	r4
    109a:	3f 90       	pop	r3
    109c:	08 95       	ret

0000109e <ax25_sendRaw>:
    if (c == HDLC_FLAG || c == HDLC_RESET || c == AX25_ESC) fputc(AX25_ESC, ctx->ch);
    ctx->crc_out = update_crc_ccit(c, ctx->crc_out);
    fputc(c, ctx->ch);
}

void ax25_sendRaw(AX25Ctx *ctx, void *_buf, size_t len) {
    109e:	8f 92       	push	r8
    10a0:	9f 92       	push	r9
    10a2:	af 92       	push	r10
    10a4:	bf 92       	push	r11
    10a6:	cf 92       	push	r12
    10a8:	df 92       	push	r13
    10aa:	ef 92       	push	r14
    10ac:	ff 92       	push	r15
    10ae:	0f 93       	push	r16
    10b0:	1f 93       	push	r17
    10b2:	cf 93       	push	r28
    10b4:	df 93       	push	r29
    10b6:	8c 01       	movw	r16, r24
    10b8:	4b 01       	movw	r8, r22
    10ba:	5a 01       	movw	r10, r20
    ctx->crc_out = CRC_CCIT_INIT_VAL;
    10bc:	6c 01       	movw	r12, r24
    10be:	80 eb       	ldi	r24, 0xB0	; 176
    10c0:	c8 1a       	sub	r12, r24
    10c2:	8e ef       	ldi	r24, 0xFE	; 254
    10c4:	d8 0a       	sbc	r13, r24
    10c6:	8f ef       	ldi	r24, 0xFF	; 255
    10c8:	9f ef       	ldi	r25, 0xFF	; 255
    10ca:	f6 01       	movw	r30, r12
    10cc:	91 83       	std	Z+1, r25	; 0x01
    10ce:	80 83       	st	Z, r24
    fputc(HDLC_FLAG, ctx->ch);
    10d0:	78 01       	movw	r14, r16
    10d2:	f6 eb       	ldi	r31, 0xB6	; 182
    10d4:	ef 1a       	sub	r14, r31
    10d6:	fe ef       	ldi	r31, 0xFE	; 254
    10d8:	ff 0a       	sbc	r15, r31
    10da:	f7 01       	movw	r30, r14
    10dc:	60 81       	ld	r22, Z
    10de:	71 81       	ldd	r23, Z+1	; 0x01
    10e0:	8e e7       	ldi	r24, 0x7E	; 126
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    10e8:	e4 01       	movw	r28, r8
    10ea:	a8 0c       	add	r10, r8
    10ec:	b9 1c       	adc	r11, r9
    const uint8_t *buf = (const uint8_t *)_buf;
    while (len--) ax25_putchar(ctx, *buf++);
    10ee:	ca 15       	cp	r28, r10
    10f0:	db 05       	cpc	r29, r11
    10f2:	29 f0       	breq	.+10     	; 0x10fe <ax25_sendRaw+0x60>
    10f4:	69 91       	ld	r22, Y+
    10f6:	c8 01       	movw	r24, r16
    10f8:	0e 94 4d 07 	call	0xe9a	; 0xe9a <ax25_putchar>
    10fc:	f8 cf       	rjmp	.-16     	; 0x10ee <ax25_sendRaw+0x50>

    uint8_t crcl = (ctx->crc_out & 0xff) ^ 0xff;
    10fe:	f6 01       	movw	r30, r12
    1100:	60 81       	ld	r22, Z
    1102:	c1 81       	ldd	r28, Z+1	; 0x01
    1104:	60 95       	com	r22
    uint8_t crch = (ctx->crc_out >> 8) ^ 0xff;
    ax25_putchar(ctx, crcl);
    1106:	c8 01       	movw	r24, r16
    1108:	0e 94 4d 07 	call	0xe9a	; 0xe9a <ax25_putchar>
    fputc(HDLC_FLAG, ctx->ch);
    const uint8_t *buf = (const uint8_t *)_buf;
    while (len--) ax25_putchar(ctx, *buf++);

    uint8_t crcl = (ctx->crc_out & 0xff) ^ 0xff;
    uint8_t crch = (ctx->crc_out >> 8) ^ 0xff;
    110c:	6c 2f       	mov	r22, r28
    110e:	60 95       	com	r22
    ax25_putchar(ctx, crcl);
    ax25_putchar(ctx, crch);
    1110:	c8 01       	movw	r24, r16
    1112:	0e 94 4d 07 	call	0xe9a	; 0xe9a <ax25_putchar>

    fputc(HDLC_FLAG, ctx->ch);
    1116:	f7 01       	movw	r30, r14
    1118:	60 81       	ld	r22, Z
    111a:	71 81       	ldd	r23, Z+1	; 0x01
    111c:	8e e7       	ldi	r24, 0x7E	; 126
    111e:	90 e0       	ldi	r25, 0x00	; 0
}
    1120:	df 91       	pop	r29
    1122:	cf 91       	pop	r28
    1124:	1f 91       	pop	r17
    1126:	0f 91       	pop	r16
    1128:	ff 90       	pop	r15
    112a:	ef 90       	pop	r14
    112c:	df 90       	pop	r13
    112e:	cf 90       	pop	r12
    1130:	bf 90       	pop	r11
    1132:	af 90       	pop	r10
    1134:	9f 90       	pop	r9
    1136:	8f 90       	pop	r8
    uint8_t crcl = (ctx->crc_out & 0xff) ^ 0xff;
    uint8_t crch = (ctx->crc_out >> 8) ^ 0xff;
    ax25_putchar(ctx, crcl);
    ax25_putchar(ctx, crch);

    fputc(HDLC_FLAG, ctx->ch);
    1138:	0c 94 cb 0e 	jmp	0x1d96	; 0x1d96 <fputc>

0000113c <is_duplicate>:
        frame_len = 0;
        rpt_hbits_out = 0x00;
    }
}

bool is_duplicate(uint8_t crcl, uint8_t crch) {
    113c:	8f 92       	push	r8
    113e:	9f 92       	push	r9
    1140:	af 92       	push	r10
    1142:	bf 92       	push	r11
    1144:	cf 92       	push	r12
    1146:	df 92       	push	r13
    1148:	ef 92       	push	r14
    114a:	ff 92       	push	r15
    114c:	cf 93       	push	r28
    114e:	df 93       	push	r29
    1150:	98 2f       	mov	r25, r24
    1152:	c6 2f       	mov	r28, r22
volatile ticks_t _clock;

inline ticks_t timer_clock(void) {
    ticks_t result;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1154:	8f b7       	in	r24, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1156:	f8 94       	cli
        result = _clock;
    1158:	40 91 0b 02 	lds	r20, 0x020B
    115c:	50 91 0c 02 	lds	r21, 0x020C
    1160:	60 91 0d 02 	lds	r22, 0x020D
    1164:	70 91 0e 02 	lds	r23, 0x020E
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1168:	8f bf       	out	0x3f, r24	; 63
    __asm__ volatile ("" ::: "memory");
    116a:	e3 e4       	ldi	r30, 0x43	; 67
    116c:	f5 e0       	ldi	r31, 0x05	; 5
    116e:	20 e0       	ldi	r18, 0x00	; 0
    1170:	30 e0       	ldi	r19, 0x00	; 0
    ticks_t now = timer_clock();
    for (int i = 0; i < DUPL_LIST_SIZE; i++) {
        if (dupl_list[i].active && now - dupl_list[i].timestamp < s_to_ticks(DUPL_STALE_TIME)) {
    1172:	80 81       	ld	r24, Z
    1174:	88 23       	and	r24, r24
    1176:	f1 f0       	breq	.+60     	; 0x11b4 <is_duplicate+0x78>
    1178:	c3 80       	ldd	r12, Z+3	; 0x03
    117a:	d4 80       	ldd	r13, Z+4	; 0x04
    117c:	e5 80       	ldd	r14, Z+5	; 0x05
    117e:	f6 80       	ldd	r15, Z+6	; 0x06
    1180:	4a 01       	movw	r8, r20
    1182:	5b 01       	movw	r10, r22
    1184:	8c 18       	sub	r8, r12
    1186:	9d 08       	sbc	r9, r13
    1188:	ae 08       	sbc	r10, r14
    118a:	bf 08       	sbc	r11, r15
    118c:	81 14       	cp	r8, r1
    118e:	a5 e6       	ldi	r26, 0x65	; 101
    1190:	9a 06       	cpc	r9, r26
    1192:	a4 e0       	ldi	r26, 0x04	; 4
    1194:	aa 06       	cpc	r10, r26
    1196:	b1 04       	cpc	r11, r1
    1198:	6c f4       	brge	.+26     	; 0x11b4 <is_duplicate+0x78>
    119a:	d9 01       	movw	r26, r18
    119c:	ad 5b       	subi	r26, 0xBD	; 189
    119e:	ba 4f       	sbci	r27, 0xFA	; 250
            if (dupl_list[i].crcl == crcl && dupl_list[i].crch == crch) {
    11a0:	11 96       	adiw	r26, 0x01	; 1
    11a2:	dc 91       	ld	r29, X
    11a4:	11 97       	sbiw	r26, 0x01	; 1
    11a6:	d9 13       	cpse	r29, r25
    11a8:	06 c0       	rjmp	.+12     	; 0x11b6 <is_duplicate+0x7a>
    11aa:	12 96       	adiw	r26, 0x02	; 2
    11ac:	ac 91       	ld	r26, X
    11ae:	ac 13       	cpse	r26, r28
    11b0:	02 c0       	rjmp	.+4      	; 0x11b6 <is_duplicate+0x7a>
    11b2:	08 c0       	rjmp	.+16     	; 0x11c4 <is_duplicate+0x88>
                return true;
            }
        } else {
            dupl_list[i].active = false;
    11b4:	10 82       	st	Z, r1
    11b6:	37 96       	adiw	r30, 0x07	; 7
    11b8:	29 5f       	subi	r18, 0xF9	; 249
    11ba:	3f 4f       	sbci	r19, 0xFF	; 255
    }
}

bool is_duplicate(uint8_t crcl, uint8_t crch) {
    ticks_t now = timer_clock();
    for (int i = 0; i < DUPL_LIST_SIZE; i++) {
    11bc:	20 3e       	cpi	r18, 0xE0	; 224
    11be:	31 05       	cpc	r19, r1
    11c0:	c1 f6       	brne	.-80     	; 0x1172 <is_duplicate+0x36>
            }
        } else {
            dupl_list[i].active = false;
        }
    }
    return false;
    11c2:	80 e0       	ldi	r24, 0x00	; 0
}
    11c4:	df 91       	pop	r29
    11c6:	cf 91       	pop	r28
    11c8:	ff 90       	pop	r15
    11ca:	ef 90       	pop	r14
    11cc:	df 90       	pop	r13
    11ce:	cf 90       	pop	r12
    11d0:	bf 90       	pop	r11
    11d2:	af 90       	pop	r10
    11d4:	9f 90       	pop	r9
    11d6:	8f 90       	pop	r8
    11d8:	08 95       	ret

000011da <digipeater_init>:

void digipeater_init(AX25Ctx *ax25, Afsk *afsk, Serial *ser) {
    ax25ctx = ax25;
    11da:	90 93 40 05 	sts	0x0540, r25
    11de:	80 93 3f 05 	sts	0x053F, r24
    serial = ser;
    11e2:	50 93 19 02 	sts	0x0219, r21
    11e6:	40 93 18 02 	sts	0x0218, r20
    channel = afsk;
    11ea:	70 93 42 05 	sts	0x0542, r23
    11ee:	60 93 41 05 	sts	0x0541, r22
    frame_len = 0;
    11f2:	10 92 70 07 	sts	0x0770, r1
    11f6:	10 92 6f 07 	sts	0x076F, r1
    11fa:	08 95       	ret

000011fc <digipeater_csma>:
}

void digipeater_csma(AX25Ctx *ctx, uint8_t *buf, size_t len) {
    11fc:	4f 92       	push	r4
    11fe:	5f 92       	push	r5
    1200:	6f 92       	push	r6
    1202:	7f 92       	push	r7
    1204:	8f 92       	push	r8
    1206:	9f 92       	push	r9
    1208:	af 92       	push	r10
    120a:	bf 92       	push	r11
    120c:	ef 92       	push	r14
    120e:	ff 92       	push	r15
    1210:	0f 93       	push	r16
    1212:	1f 93       	push	r17
    1214:	cf 93       	push	r28
    1216:	df 93       	push	r29
    1218:	ec 01       	movw	r28, r24
    121a:	8b 01       	movw	r16, r22
    121c:	7a 01       	movw	r14, r20
    bool sent = false;
    csma_waiting = true;
    121e:	81 e0       	ldi	r24, 0x01	; 1
    1220:	80 93 40 01 	sts	0x0140, r24
    while (!sent) {
        if(!channel->hdlc.receiving) {
    1224:	e0 91 41 05 	lds	r30, 0x0541
    1228:	f0 91 42 05 	lds	r31, 0x0542
    122c:	81 89       	ldd	r24, Z+17	; 0x11
    122e:	81 11       	cpse	r24, r1
    1230:	38 c0       	rjmp	.+112    	; 0x12a2 <digipeater_csma+0xa6>
            uint8_t tp = rand() & 0xFF;
    1232:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <rand>
            if (tp < p) {
    1236:	90 91 09 01 	lds	r25, 0x0109
    123a:	89 17       	cp	r24, r25
    123c:	30 f4       	brcc	.+12     	; 0x124a <digipeater_csma+0x4e>
                ax25_sendRaw(ctx, buf, len);
    123e:	a7 01       	movw	r20, r14
    1240:	b8 01       	movw	r22, r16
    1242:	ce 01       	movw	r24, r28
    1244:	0e 94 4f 08 	call	0x109e	; 0x109e <ax25_sendRaw>
    1248:	46 c0       	rjmp	.+140    	; 0x12d6 <digipeater_csma+0xda>
volatile ticks_t _clock;

inline ticks_t timer_clock(void) {
    ticks_t result;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    124a:	8f b7       	in	r24, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    124c:	f8 94       	cli
        result = _clock;
    124e:	80 90 0b 02 	lds	r8, 0x020B
    1252:	90 90 0c 02 	lds	r9, 0x020C
    1256:	a0 90 0d 02 	lds	r10, 0x020D
    125a:	b0 90 0e 02 	lds	r11, 0x020E
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    125e:	8f bf       	out	0x3f, r24	; 63
    return result;
}


inline ticks_t ms_to_ticks(mtime_t ms) {
    return ms * DIV_ROUND(CLOCK_TICKS_PER_SEC, 1000);
    1260:	20 91 0a 01 	lds	r18, 0x010A
    1264:	30 91 0b 01 	lds	r19, 0x010B
    1268:	40 91 0c 01 	lds	r20, 0x010C
    126c:	50 91 0d 01 	lds	r21, 0x010D
    1270:	aa e0       	ldi	r26, 0x0A	; 10
    1272:	b0 e0       	ldi	r27, 0x00	; 0
    1274:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <__muluhisi3>
volatile ticks_t _clock;

inline ticks_t timer_clock(void) {
    ticks_t result;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1278:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    127a:	f8 94       	cli
        result = _clock;
    127c:	40 90 0b 02 	lds	r4, 0x020B
    1280:	50 90 0c 02 	lds	r5, 0x020C
    1284:	60 90 0d 02 	lds	r6, 0x020D
    1288:	70 90 0e 02 	lds	r7, 0x020E
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    128c:	2f bf       	out	0x3f, r18	; 63
                sent = true;
                csma_waiting = false;
            } else {
                ticks_t start = timer_clock();
                long slot_ticks = ms_to_ticks(slotTime);
                while (timer_clock() - start < slot_ticks) {
    128e:	48 18       	sub	r4, r8
    1290:	59 08       	sbc	r5, r9
    1292:	6a 08       	sbc	r6, r10
    1294:	7b 08       	sbc	r7, r11
    1296:	46 16       	cp	r4, r22
    1298:	57 06       	cpc	r5, r23
    129a:	68 06       	cpc	r6, r24
    129c:	79 06       	cpc	r7, r25
    129e:	64 f3       	brlt	.-40     	; 0x1278 <digipeater_csma+0x7c>
    12a0:	c1 cf       	rjmp	.-126    	; 0x1224 <digipeater_csma+0x28>
                    cpu_relax();
                }
            }
        } else {
            while (!sent && channel->hdlc.receiving) {
    12a2:	e0 91 41 05 	lds	r30, 0x0541
    12a6:	f0 91 42 05 	lds	r31, 0x0542
    12aa:	81 89       	ldd	r24, Z+17	; 0x11
    12ac:	88 23       	and	r24, r24
    12ae:	09 f4       	brne	.+2      	; 0x12b2 <digipeater_csma+0xb6>
    12b0:	b9 cf       	rjmp	.-142    	; 0x1224 <digipeater_csma+0x28>
                // Continously poll the modem for data
                // while waiting, so we don't overrun
                // receive buffers
                ax25_poll(ax25ctx);
    12b2:	80 91 3f 05 	lds	r24, 0x053F
    12b6:	90 91 40 05 	lds	r25, 0x0540
    12ba:	0e 94 a9 07 	call	0xf52	; 0xf52 <ax25_poll>

                if (channel->status != 0) {
    12be:	e0 91 41 05 	lds	r30, 0x0541
    12c2:	f0 91 42 05 	lds	r31, 0x0542
    12c6:	e8 53       	subi	r30, 0x38	; 56
    12c8:	ff 4f       	sbci	r31, 0xFF	; 255
    12ca:	80 81       	ld	r24, Z
    12cc:	91 81       	ldd	r25, Z+1	; 0x01
    12ce:	89 2b       	or	r24, r25
    12d0:	41 f3       	breq	.-48     	; 0x12a2 <digipeater_csma+0xa6>
                    // If an overflow or other error
                    // occurs, we'll back off and drop
                    // this packet silently.
                    channel->status = 0;
    12d2:	11 82       	std	Z+1, r1	; 0x01
    12d4:	10 82       	st	Z, r1
                    sent = true;
                    csma_waiting = false;
    12d6:	10 92 40 01 	sts	0x0140, r1
                }
            }
        }

    }
}
    12da:	df 91       	pop	r29
    12dc:	cf 91       	pop	r28
    12de:	1f 91       	pop	r17
    12e0:	0f 91       	pop	r16
    12e2:	ff 90       	pop	r15
    12e4:	ef 90       	pop	r14
    12e6:	bf 90       	pop	r11
    12e8:	af 90       	pop	r10
    12ea:	9f 90       	pop	r9
    12ec:	8f 90       	pop	r8
    12ee:	7f 90       	pop	r7
    12f0:	6f 90       	pop	r6
    12f2:	5f 90       	pop	r5
    12f4:	4f 90       	pop	r4
    12f6:	08 95       	ret

000012f8 <digipeater_processPackets>:
    static int clamp_n = 1;
#else
    static int clamp_n = DIGIPEATER_CLAMP_N;
#endif

void digipeater_processPackets(void) {
    12f8:	2f 92       	push	r2
    12fa:	3f 92       	push	r3
    12fc:	4f 92       	push	r4
    12fe:	5f 92       	push	r5
    1300:	6f 92       	push	r6
    1302:	7f 92       	push	r7
    1304:	8f 92       	push	r8
    1306:	9f 92       	push	r9
    1308:	af 92       	push	r10
    130a:	bf 92       	push	r11
    130c:	cf 92       	push	r12
    130e:	df 92       	push	r13
    1310:	ef 92       	push	r14
    1312:	ff 92       	push	r15
    1314:	0f 93       	push	r16
    1316:	1f 93       	push	r17
    1318:	cf 93       	push	r28
    131a:	df 93       	push	r29
    131c:	cd b7       	in	r28, 0x3d	; 61
    131e:	de b7       	in	r29, 0x3e	; 62
    1320:	2e 97       	sbiw	r28, 0x0e	; 14
    1322:	0f b6       	in	r0, 0x3f	; 63
    1324:	f8 94       	cli
    1326:	de bf       	out	0x3e, r29	; 62
    1328:	0f be       	out	0x3f, r0	; 63
    132a:	cd bf       	out	0x3d, r28	; 61
    // If we're waiting in CSMA, drop this packet
    if (csma_waiting) frame_len = 0;
    132c:	80 91 40 01 	lds	r24, 0x0140
    1330:	88 23       	and	r24, r24
    1332:	21 f0       	breq	.+8      	; 0x133c <digipeater_processPackets+0x44>
    1334:	10 92 70 07 	sts	0x0770, r1
    1338:	10 92 6f 07 	sts	0x076F, r1

    if (frame_len != 0) {
    133c:	80 91 6f 07 	lds	r24, 0x076F
    1340:	90 91 70 07 	lds	r25, 0x0770
    1344:	89 2b       	or	r24, r25
    1346:	09 f4       	brne	.+2      	; 0x134a <digipeater_processPackets+0x52>
    1348:	da c3       	rjmp	.+1972   	; 0x1afe <digipeater_processPackets+0x806>
    134a:	e5 ef       	ldi	r30, 0xF5	; 245
    134c:	f3 e0       	ldi	r31, 0x03	; 3
    134e:	20 e1       	ldi	r18, 0x10	; 16
    1350:	32 e0       	ldi	r19, 0x02	; 2
    1352:	3b 87       	std	Y+11, r19	; 0x0b
    1354:	2a 87       	std	Y+10, r18	; 0x0a
    1356:	d9 01       	movw	r26, r18
        uint8_t *buf = packetBuffer;
        uint8_t *bufStart = packetBuffer;
        bool repeat = false;
        bool unrelated = false;

        DECODE_CALL(buf, dst.call);
    1358:	81 91       	ld	r24, Z+
    135a:	86 95       	lsr	r24
    135c:	80 32       	cpi	r24, 0x20	; 32
    135e:	09 f4       	brne	.+2      	; 0x1362 <digipeater_processPackets+0x6a>
    1360:	80 e0       	ldi	r24, 0x00	; 0
    1362:	8d 93       	st	X+, r24
    1364:	33 e0       	ldi	r19, 0x03	; 3
    1366:	eb 3f       	cpi	r30, 0xFB	; 251
    1368:	f3 07       	cpc	r31, r19
    136a:	b1 f7       	brne	.-20     	; 0x1358 <digipeater_processPackets+0x60>
        dst.ssid = (*buf++ >> 1) & 0x0F;
    136c:	80 91 fb 03 	lds	r24, 0x03FB
    1370:	86 95       	lsr	r24
    1372:	8f 70       	andi	r24, 0x0F	; 15
    1374:	80 93 16 02 	sts	0x0216, r24
    1378:	ac ef       	ldi	r26, 0xFC	; 252
    137a:	b3 e0       	ldi	r27, 0x03	; 3
    137c:	2e e5       	ldi	r18, 0x5E	; 94
    137e:	32 e0       	ldi	r19, 0x02	; 2
    1380:	39 87       	std	Y+9, r19	; 0x09
    1382:	28 87       	std	Y+8, r18	; 0x08
    1384:	f9 01       	movw	r30, r18

        DECODE_CALL(buf, src.call);
    1386:	8d 91       	ld	r24, X+
    1388:	86 95       	lsr	r24
    138a:	80 32       	cpi	r24, 0x20	; 32
    138c:	09 f4       	brne	.+2      	; 0x1390 <digipeater_processPackets+0x98>
    138e:	80 e0       	ldi	r24, 0x00	; 0
    1390:	81 93       	st	Z+, r24
    1392:	32 e0       	ldi	r19, 0x02	; 2
    1394:	e4 36       	cpi	r30, 0x64	; 100
    1396:	f3 07       	cpc	r31, r19
    1398:	b1 f7       	brne	.-20     	; 0x1386 <digipeater_processPackets+0x8e>
        src.ssid = (*buf >> 1) & 0x0F;
    139a:	70 90 02 04 	lds	r7, 0x0402
    139e:	87 2d       	mov	r24, r7
    13a0:	86 95       	lsr	r24
    13a2:	8f 70       	andi	r24, 0x0F	; 15
    13a4:	8e 87       	std	Y+14, r24	; 0x0e
    13a6:	80 93 64 02 	sts	0x0264, r24

        uint8_t rpt_count;
        uint8_t rpt_count_out = 0;
        rpt_hbits = 0x00;
    13aa:	10 92 0f 02 	sts	0x020F, r1
    13ae:	36 e2       	ldi	r19, 0x26	; 38
    13b0:	23 2e       	mov	r2, r19
    13b2:	32 e0       	ldi	r19, 0x02	; 2
    13b4:	33 2e       	mov	r3, r19
        for (rpt_count = 0; !(*buf++ & 0x01) && (rpt_count < countof(rpt_list)); rpt_count++) {
    13b6:	71 01       	movw	r14, r2
    13b8:	1d 86       	std	Y+13, r1	; 0x0d
    13ba:	1c 86       	std	Y+12, r1	; 0x0c

        DECODE_CALL(buf, src.call);
        src.ssid = (*buf >> 1) & 0x0F;

        uint8_t rpt_count;
        uint8_t rpt_count_out = 0;
    13bc:	d1 2c       	mov	r13, r1
        rpt_hbits = 0x00;
        for (rpt_count = 0; !(*buf++ & 0x01) && (rpt_count < countof(rpt_list)); rpt_count++) {
    13be:	41 2c       	mov	r4, r1
        // We have a packet for digipeating,
        // let's process it
        uint8_t *buf = packetBuffer;
        uint8_t *bufStart = packetBuffer;
        bool repeat = false;
        bool unrelated = false;
    13c0:	c1 2c       	mov	r12, r1
    if (frame_len != 0) {
        // We have a packet for digipeating,
        // let's process it
        uint8_t *buf = packetBuffer;
        uint8_t *bufStart = packetBuffer;
        bool repeat = false;
    13c2:	51 2c       	mov	r5, r1
        bool unrelated = false;

        DECODE_CALL(buf, dst.call);
        dst.ssid = (*buf++ >> 1) & 0x0F;

        DECODE_CALL(buf, src.call);
    13c4:	42 e0       	ldi	r20, 0x02	; 2
    13c6:	84 2e       	mov	r8, r20
    13c8:	44 e0       	ldi	r20, 0x04	; 4
    13ca:	94 2e       	mov	r9, r20
                    } else {
                        unrelated = true;
                    }
                }
            } else {
                memcpy(rpt_list_out[rpt_count_out].call, rpt_list[rpt_count].call, 6);
    13cc:	57 e0       	ldi	r21, 0x07	; 7
    13ce:	65 2e       	mov	r6, r21
    13d0:	66 e0       	ldi	r22, 0x06	; 6
    13d2:	76 2e       	mov	r7, r22
                rpt_list_out[rpt_count_out].ssid = rpt_list[rpt_count].ssid;
                if (hbit) rpt_hbits_out |= (0x01 << rpt_count_out);
    13d4:	aa 24       	eor	r10, r10
    13d6:	a3 94       	inc	r10
    13d8:	b1 2c       	mov	r11, r1
        src.ssid = (*buf >> 1) & 0x0F;

        uint8_t rpt_count;
        uint8_t rpt_count_out = 0;
        rpt_hbits = 0x00;
        for (rpt_count = 0; !(*buf++ & 0x01) && (rpt_count < countof(rpt_list)); rpt_count++) {
    13da:	84 01       	movw	r16, r8
    13dc:	0f 5f       	subi	r16, 0xFF	; 255
    13de:	1f 4f       	sbci	r17, 0xFF	; 255
    13e0:	d4 01       	movw	r26, r8
    13e2:	8c 91       	ld	r24, X
    13e4:	80 fd       	sbrc	r24, 0
    13e6:	18 c1       	rjmp	.+560    	; 0x1618 <digipeater_processPackets+0x320>
    13e8:	b8 e0       	ldi	r27, 0x08	; 8
    13ea:	4b 16       	cp	r4, r27
    13ec:	09 f4       	brne	.+2      	; 0x13f0 <digipeater_processPackets+0xf8>
    13ee:	14 c1       	rjmp	.+552    	; 0x1618 <digipeater_processPackets+0x320>
    13f0:	f8 01       	movw	r30, r16
    13f2:	80 e0       	ldi	r24, 0x00	; 0
    13f4:	90 e0       	ldi	r25, 0x00	; 0
            DECODE_CALL(buf, rpt_list[rpt_count].call);
    13f6:	21 91       	ld	r18, Z+
    13f8:	26 95       	lsr	r18
    13fa:	20 32       	cpi	r18, 0x20	; 32
    13fc:	09 f4       	brne	.+2      	; 0x1400 <digipeater_processPackets+0x108>
    13fe:	20 e0       	ldi	r18, 0x00	; 0
    1400:	d7 01       	movw	r26, r14
    1402:	a8 0f       	add	r26, r24
    1404:	b9 1f       	adc	r27, r25
    1406:	2c 93       	st	X, r18
    1408:	01 96       	adiw	r24, 0x01	; 1
    140a:	86 30       	cpi	r24, 0x06	; 6
    140c:	91 05       	cpc	r25, r1
    140e:	99 f7       	brne	.-26     	; 0x13f6 <digipeater_processPackets+0xfe>
    1410:	67 e0       	ldi	r22, 0x07	; 7
    1412:	86 0e       	add	r8, r22
    1414:	91 1c       	adc	r9, r1
            rpt_list[rpt_count].ssid = (*buf >> 1) & 0x0F;
    1416:	d4 01       	movw	r26, r8
    1418:	8c 91       	ld	r24, X
    141a:	18 2f       	mov	r17, r24
    141c:	16 95       	lsr	r17
    141e:	1f 70       	andi	r17, 0x0F	; 15
    1420:	f7 01       	movw	r30, r14
    1422:	16 83       	std	Z+6, r17	; 0x06

            bool hbit = (*buf >> 7);
    1424:	28 2f       	mov	r18, r24
    1426:	22 1f       	adc	r18, r18
    1428:	22 27       	eor	r18, r18
    142a:	22 1f       	adc	r18, r18
            rpt_hbits |= (hbit << rpt_count);
    142c:	82 2f       	mov	r24, r18
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	0c 84       	ldd	r0, Y+12	; 0x0c
    1432:	02 c0       	rjmp	.+4      	; 0x1438 <digipeater_processPackets+0x140>
    1434:	88 0f       	add	r24, r24
    1436:	99 1f       	adc	r25, r25
    1438:	0a 94       	dec	r0
    143a:	e2 f7       	brpl	.-8      	; 0x1434 <digipeater_processPackets+0x13c>
    143c:	90 91 0f 02 	lds	r25, 0x020F
    1440:	89 2b       	or	r24, r25
    1442:	80 93 0f 02 	sts	0x020F, r24

            if (!hbit && !repeat && !unrelated) {
    1446:	21 11       	cpse	r18, r1
    1448:	bd c0       	rjmp	.+378    	; 0x15c4 <digipeater_processPackets+0x2cc>
    144a:	51 10       	cpse	r5, r1
    144c:	bb c0       	rjmp	.+374    	; 0x15c4 <digipeater_processPackets+0x2cc>
    144e:	c1 10       	cpse	r12, r1
    1450:	b9 c0       	rjmp	.+370    	; 0x15c4 <digipeater_processPackets+0x2cc>
                // If the H-bit is not set, this path
                // component is active, and we should
                // check whether to digipeat
                AX25Call *path_call = &rpt_list[rpt_count];

                if (specificDigipeat && memcmp(DIGIPEATER_CALLSIGN, path_call->call, MIN(sizeof(path_call->call), strlen(path_call->call))) == 0 && rpt_list[rpt_count].ssid == DIGIPEATER_SSID) {
    1452:	80 91 08 01 	lds	r24, 0x0108
    1456:	88 23       	and	r24, r24
    1458:	b1 f1       	breq	.+108    	; 0x14c6 <digipeater_processPackets+0x1ce>
    145a:	01 90       	ld	r0, Z+
    145c:	00 20       	and	r0, r0
    145e:	e9 f7       	brne	.-6      	; 0x145a <digipeater_processPackets+0x162>
    1460:	31 97       	sbiw	r30, 0x01	; 1
    1462:	af 01       	movw	r20, r30
    1464:	4e 19       	sub	r20, r14
    1466:	5f 09       	sbc	r21, r15
    1468:	47 30       	cpi	r20, 0x07	; 7
    146a:	51 05       	cpc	r21, r1
    146c:	10 f0       	brcs	.+4      	; 0x1472 <digipeater_processPackets+0x17a>
    146e:	46 e0       	ldi	r20, 0x06	; 6
    1470:	50 e0       	ldi	r21, 0x00	; 0
    1472:	b7 01       	movw	r22, r14
    1474:	82 e1       	ldi	r24, 0x12	; 18
    1476:	91 e0       	ldi	r25, 0x01	; 1
    1478:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <memcmp>
    147c:	89 2b       	or	r24, r25
    147e:	19 f5       	brne	.+70     	; 0x14c6 <digipeater_processPackets+0x1ce>
    1480:	1b 30       	cpi	r17, 0x0B	; 11
    1482:	09 f5       	brne	.+66     	; 0x14c6 <digipeater_processPackets+0x1ce>
                    // This packet is relayed through
                    // us specifically
                    memcpy(rpt_list_out[rpt_count_out].call, DIGIPEATER_CALLSIGN, 6);
    1484:	6d 9c       	mul	r6, r13
    1486:	c0 01       	movw	r24, r0
    1488:	11 24       	eor	r1, r1
    148a:	85 54       	subi	r24, 0x45	; 69
    148c:	9c 4f       	sbci	r25, 0xFC	; 252
    148e:	e2 e1       	ldi	r30, 0x12	; 18
    1490:	f1 e0       	ldi	r31, 0x01	; 1
    1492:	dc 01       	movw	r26, r24
    1494:	27 2d       	mov	r18, r7
    1496:	01 90       	ld	r0, Z+
    1498:	0d 92       	st	X+, r0
    149a:	2a 95       	dec	r18
    149c:	e1 f7       	brne	.-8      	; 0x1496 <digipeater_processPackets+0x19e>
                    rpt_list_out[rpt_count_out].ssid = DIGIPEATER_SSID;
    149e:	dc 01       	movw	r26, r24
    14a0:	16 96       	adiw	r26, 0x06	; 6
    14a2:	1c 93       	st	X, r17
                    rpt_hbits_out |= (0x01 << rpt_count_out);
    14a4:	c5 01       	movw	r24, r10
    14a6:	0d 2c       	mov	r0, r13
    14a8:	01 c0       	rjmp	.+2      	; 0x14ac <digipeater_processPackets+0x1b4>
    14aa:	88 0f       	add	r24, r24
    14ac:	0a 94       	dec	r0
    14ae:	ea f7       	brpl	.-6      	; 0x14aa <digipeater_processPackets+0x1b2>
    14b0:	90 91 17 02 	lds	r25, 0x0217
    14b4:	89 2b       	or	r24, r25
    14b6:	80 93 17 02 	sts	0x0217, r24
                    rpt_count_out++;
    14ba:	d3 94       	inc	r13
                    repeat = true;
                    frame_len_out = 0;
    14bc:	10 92 24 06 	sts	0x0624, r1
    14c0:	10 92 23 06 	sts	0x0623, r1
    14c4:	7c c0       	rjmp	.+248    	; 0x15be <digipeater_processPackets+0x2c6>
                } else {
                    if (rpt_list[rpt_count].ssid > 0) {
    14c6:	11 23       	and	r17, r17
    14c8:	09 f4       	brne	.+2      	; 0x14cc <digipeater_processPackets+0x1d4>
    14ca:	99 c0       	rjmp	.+306    	; 0x15fe <digipeater_processPackets+0x306>
                        if (memcmp("TRACE", path_call->call, 5) == 0) r = true;
    14cc:	45 e0       	ldi	r20, 0x05	; 5
    14ce:	50 e0       	ldi	r21, 0x00	; 0
    14d0:	b7 01       	movw	r22, r14
    14d2:	89 e1       	ldi	r24, 0x19	; 25
    14d4:	91 e0       	ldi	r25, 0x01	; 1
    14d6:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <memcmp>
    14da:	89 2b       	or	r24, r25
    14dc:	19 f4       	brne	.+6      	; 0x14e4 <digipeater_processPackets+0x1ec>
    14de:	b1 e0       	ldi	r27, 0x01	; 1
    14e0:	b0 93 3f 01 	sts	0x013F, r27
                        if ((memcmp("WIDE", path_call->call, 4) == 0) | r) {
    14e4:	44 e0       	ldi	r20, 0x04	; 4
    14e6:	50 e0       	ldi	r21, 0x00	; 0
    14e8:	b7 01       	movw	r22, r14
    14ea:	8f e1       	ldi	r24, 0x1F	; 31
    14ec:	91 e0       	ldi	r25, 0x01	; 1
    14ee:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <memcmp>
    14f2:	20 91 3f 01 	lds	r18, 0x013F
    14f6:	89 2b       	or	r24, r25
    14f8:	19 f0       	breq	.+6      	; 0x1500 <digipeater_processPackets+0x208>
    14fa:	22 23       	and	r18, r18
    14fc:	09 f4       	brne	.+2      	; 0x1500 <digipeater_processPackets+0x208>
    14fe:	7f c0       	rjmp	.+254    	; 0x15fe <digipeater_processPackets+0x306>
    1500:	c7 01       	movw	r24, r14
                            char *p = path_call->call + 4;
  			    if (r) {p = path_call->call + 5;}
    1502:	21 11       	cpse	r18, r1
    1504:	02 c0       	rjmp	.+4      	; 0x150a <digipeater_processPackets+0x212>
    1506:	04 96       	adiw	r24, 0x04	; 4
    1508:	01 c0       	rjmp	.+2      	; 0x150c <digipeater_processPackets+0x214>
    150a:	05 96       	adiw	r24, 0x05	; 5
                            int n = atoi(p);
    150c:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <atoi>
                            int N = rpt_list[rpt_count].ssid;
                            bool dupl_match = false;

                            if (n <= clamp_n && N <= clamp_n && !dupl_match) {
    1510:	06 97       	sbiw	r24, 0x06	; 6
    1512:	0c f0       	brlt	.+2      	; 0x1516 <digipeater_processPackets+0x21e>
    1514:	74 c0       	rjmp	.+232    	; 0x15fe <digipeater_processPackets+0x306>
    1516:	16 30       	cpi	r17, 0x06	; 6
    1518:	08 f0       	brcs	.+2      	; 0x151c <digipeater_processPackets+0x224>
    151a:	71 c0       	rjmp	.+226    	; 0x15fe <digipeater_processPackets+0x306>
                                repeat = true;
                                frame_len_out = 0;
    151c:	10 92 24 06 	sts	0x0624, r1
    1520:	10 92 23 06 	sts	0x0623, r1
                                uint8_t rssid = rpt_list[rpt_count].ssid - 1;
    1524:	11 50       	subi	r17, 0x01	; 1
    1526:	2d 2d       	mov	r18, r13
    1528:	30 e0       	ldi	r19, 0x00	; 0
                                if (rssid == 0) {
                                    // If n has reached 0, replace the
                                    // WIDE with our own call, and set
                                    // the H-bit
                                    //memset(rpt_list[rpt_count].call, 0, 6);
                                    memcpy(rpt_list_out[rpt_count_out].call, DIGIPEATER_CALLSIGN, 6);
    152a:	62 9e       	mul	r6, r18
    152c:	c0 01       	movw	r24, r0
    152e:	63 9e       	mul	r6, r19
    1530:	90 0d       	add	r25, r0
    1532:	11 24       	eor	r1, r1
    1534:	85 54       	subi	r24, 0x45	; 69
    1536:	9c 4f       	sbci	r25, 0xFC	; 252
    1538:	e2 e1       	ldi	r30, 0x12	; 18
    153a:	f1 e0       	ldi	r31, 0x01	; 1
    153c:	dc 01       	movw	r26, r24
    153e:	27 2d       	mov	r18, r7
    1540:	01 90       	ld	r0, Z+
    1542:	0d 92       	st	X+, r0
    1544:	2a 95       	dec	r18
    1546:	e1 f7       	brne	.-8      	; 0x1540 <digipeater_processPackets+0x248>

                            if (n <= clamp_n && N <= clamp_n && !dupl_match) {
                                repeat = true;
                                frame_len_out = 0;
                                uint8_t rssid = rpt_list[rpt_count].ssid - 1;
                                if (rssid == 0) {
    1548:	11 11       	cpse	r17, r1
    154a:	10 c0       	rjmp	.+32     	; 0x156c <digipeater_processPackets+0x274>
                                    // If n has reached 0, replace the
                                    // WIDE with our own call, and set
                                    // the H-bit
                                    //memset(rpt_list[rpt_count].call, 0, 6);
                                    memcpy(rpt_list_out[rpt_count_out].call, DIGIPEATER_CALLSIGN, 6);
                                    rpt_list_out[rpt_count_out].ssid = DIGIPEATER_SSID;
    154c:	2b e0       	ldi	r18, 0x0B	; 11
    154e:	fc 01       	movw	r30, r24
    1550:	26 83       	std	Z+6, r18	; 0x06
                                    rpt_hbits_out |= (0x01 << rpt_count_out);
    1552:	c5 01       	movw	r24, r10
    1554:	0d 2c       	mov	r0, r13
    1556:	01 c0       	rjmp	.+2      	; 0x155a <digipeater_processPackets+0x262>
    1558:	88 0f       	add	r24, r24
    155a:	0a 94       	dec	r0
    155c:	ea f7       	brpl	.-6      	; 0x1558 <digipeater_processPackets+0x260>
    155e:	90 91 17 02 	lds	r25, 0x0217
    1562:	89 2b       	or	r24, r25
    1564:	80 93 17 02 	sts	0x0217, r24
                                    rpt_count_out++;
    1568:	d3 94       	inc	r13
    156a:	29 c0       	rjmp	.+82     	; 0x15be <digipeater_processPackets+0x2c6>
                                    // If not, insert our own callsign,
                                    // set the H-bit and then add the
                                    // Rest of the WIDE, decrementing
                                    // the n part
                                    memcpy(rpt_list_out[rpt_count_out].call, DIGIPEATER_CALLSIGN, 6);
                                    rpt_list_out[rpt_count_out].ssid = DIGIPEATER_SSID;
    156c:	eb e0       	ldi	r30, 0x0B	; 11
    156e:	dc 01       	movw	r26, r24
    1570:	16 96       	adiw	r26, 0x06	; 6
    1572:	ec 93       	st	X, r30
                                    rpt_hbits_out |= (0x01 << rpt_count_out);
    1574:	c5 01       	movw	r24, r10
    1576:	0d 2c       	mov	r0, r13
    1578:	01 c0       	rjmp	.+2      	; 0x157c <digipeater_processPackets+0x284>
    157a:	88 0f       	add	r24, r24
    157c:	0a 94       	dec	r0
    157e:	ea f7       	brpl	.-6      	; 0x157a <digipeater_processPackets+0x282>
    1580:	90 91 17 02 	lds	r25, 0x0217
    1584:	89 2b       	or	r24, r25
                                    rpt_count_out++;
    1586:	91 e0       	ldi	r25, 0x01	; 1
    1588:	9d 0d       	add	r25, r13

                                    memcpy(rpt_list_out[rpt_count_out].call, rpt_list[rpt_count].call, 6);
    158a:	69 9e       	mul	r6, r25
    158c:	90 01       	movw	r18, r0
    158e:	11 24       	eor	r1, r1
    1590:	25 54       	subi	r18, 0x45	; 69
    1592:	3c 4f       	sbci	r19, 0xFC	; 252
    1594:	f7 01       	movw	r30, r14
    1596:	d9 01       	movw	r26, r18
    1598:	47 2d       	mov	r20, r7
    159a:	01 90       	ld	r0, Z+
    159c:	0d 92       	st	X+, r0
    159e:	4a 95       	dec	r20
    15a0:	e1 f7       	brne	.-8      	; 0x159a <digipeater_processPackets+0x2a2>
                                    rpt_list_out[rpt_count_out].ssid = rssid;
    15a2:	d9 01       	movw	r26, r18
    15a4:	16 96       	adiw	r26, 0x06	; 6
    15a6:	1c 93       	st	X, r17
                                    rpt_hbits_out &= 0xFF ^ (0x01 << rpt_count_out);
    15a8:	95 01       	movw	r18, r10
    15aa:	01 c0       	rjmp	.+2      	; 0x15ae <digipeater_processPackets+0x2b6>
    15ac:	22 0f       	add	r18, r18
    15ae:	9a 95       	dec	r25
    15b0:	ea f7       	brpl	.-6      	; 0x15ac <digipeater_processPackets+0x2b4>
    15b2:	20 95       	com	r18
    15b4:	82 23       	and	r24, r18
    15b6:	80 93 17 02 	sts	0x0217, r24
                                    rpt_count_out++;
    15ba:	d3 94       	inc	r13
    15bc:	d3 94       	inc	r13
                            int n = atoi(p);
                            int N = rpt_list[rpt_count].ssid;
                            bool dupl_match = false;

                            if (n <= clamp_n && N <= clamp_n && !dupl_match) {
                                repeat = true;
    15be:	55 24       	eor	r5, r5
    15c0:	53 94       	inc	r5
    15c2:	1f c0       	rjmp	.+62     	; 0x1602 <digipeater_processPackets+0x30a>
                    } else {
                        unrelated = true;
                    }
                }
            } else {
                memcpy(rpt_list_out[rpt_count_out].call, rpt_list[rpt_count].call, 6);
    15c4:	6d 9c       	mul	r6, r13
    15c6:	c0 01       	movw	r24, r0
    15c8:	11 24       	eor	r1, r1
    15ca:	85 54       	subi	r24, 0x45	; 69
    15cc:	9c 4f       	sbci	r25, 0xFC	; 252
    15ce:	f7 01       	movw	r30, r14
    15d0:	dc 01       	movw	r26, r24
    15d2:	37 2d       	mov	r19, r7
    15d4:	01 90       	ld	r0, Z+
    15d6:	0d 92       	st	X+, r0
    15d8:	3a 95       	dec	r19
    15da:	e1 f7       	brne	.-8      	; 0x15d4 <digipeater_processPackets+0x2dc>
                rpt_list_out[rpt_count_out].ssid = rpt_list[rpt_count].ssid;
    15dc:	fc 01       	movw	r30, r24
    15de:	16 83       	std	Z+6, r17	; 0x06
                if (hbit) rpt_hbits_out |= (0x01 << rpt_count_out);
    15e0:	22 23       	and	r18, r18
    15e2:	59 f0       	breq	.+22     	; 0x15fa <digipeater_processPackets+0x302>
    15e4:	20 91 17 02 	lds	r18, 0x0217
    15e8:	c5 01       	movw	r24, r10
    15ea:	0d 2c       	mov	r0, r13
    15ec:	01 c0       	rjmp	.+2      	; 0x15f0 <digipeater_processPackets+0x2f8>
    15ee:	88 0f       	add	r24, r24
    15f0:	0a 94       	dec	r0
    15f2:	ea f7       	brpl	.-6      	; 0x15ee <digipeater_processPackets+0x2f6>
    15f4:	82 2b       	or	r24, r18
    15f6:	80 93 17 02 	sts	0x0217, r24
                rpt_count_out++;
    15fa:	d3 94       	inc	r13
    15fc:	02 c0       	rjmp	.+4      	; 0x1602 <digipeater_processPackets+0x30a>
                                    rpt_list_out[rpt_count_out].ssid = rssid;
                                    rpt_hbits_out &= 0xFF ^ (0x01 << rpt_count_out);
                                    rpt_count_out++;
                                }
                            } else {
                                unrelated = true;
    15fe:	cc 24       	eor	r12, r12
    1600:	c3 94       	inc	r12
        src.ssid = (*buf >> 1) & 0x0F;

        uint8_t rpt_count;
        uint8_t rpt_count_out = 0;
        rpt_hbits = 0x00;
        for (rpt_count = 0; !(*buf++ & 0x01) && (rpt_count < countof(rpt_list)); rpt_count++) {
    1602:	43 94       	inc	r4
    1604:	2c 85       	ldd	r18, Y+12	; 0x0c
    1606:	3d 85       	ldd	r19, Y+13	; 0x0d
    1608:	2f 5f       	subi	r18, 0xFF	; 255
    160a:	3f 4f       	sbci	r19, 0xFF	; 255
    160c:	3d 87       	std	Y+13, r19	; 0x0d
    160e:	2c 87       	std	Y+12, r18	; 0x0c
    1610:	37 e0       	ldi	r19, 0x07	; 7
    1612:	e3 0e       	add	r14, r19
    1614:	f1 1c       	adc	r15, r1
    1616:	e1 ce       	rjmp	.-574    	; 0x13da <digipeater_processPackets+0xe2>
            }

        }

        #if SERIAL_DEBUG
            printf_P(PSTR("SRC[%.6s-%d] "), src.call, src.ssid);
    1618:	1f 92       	push	r1
    161a:	ee 84       	ldd	r14, Y+14	; 0x0e
    161c:	ef 92       	push	r14
    161e:	8e e5       	ldi	r24, 0x5E	; 94
    1620:	92 e0       	ldi	r25, 0x02	; 2
    1622:	9f 93       	push	r25
    1624:	8f 93       	push	r24
    1626:	8d e6       	ldi	r24, 0x6D	; 109
    1628:	93 e0       	ldi	r25, 0x03	; 3
    162a:	9f 93       	push	r25
    162c:	8f 93       	push	r24
    162e:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <printf_P>
            printf_P(PSTR("DST[%.6s-%d] "), dst.call, dst.ssid);
    1632:	80 e1       	ldi	r24, 0x10	; 16
    1634:	92 e0       	ldi	r25, 0x02	; 2
    1636:	20 91 16 02 	lds	r18, 0x0216
    163a:	1f 92       	push	r1
    163c:	2f 93       	push	r18
    163e:	9f 93       	push	r25
    1640:	8f 93       	push	r24
    1642:	8f e5       	ldi	r24, 0x5F	; 95
    1644:	93 e0       	ldi	r25, 0x03	; 3
    1646:	9f 93       	push	r25
    1648:	8f 93       	push	r24
    164a:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <printf_P>
            printf_P(PSTR("\nRXd Path (%d): "), rpt_count);
    164e:	1f 92       	push	r1
    1650:	4f 92       	push	r4
    1652:	8e e4       	ldi	r24, 0x4E	; 78
    1654:	93 e0       	ldi	r25, 0x03	; 3
    1656:	9f 93       	push	r25
    1658:	8f 93       	push	r24
    165a:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <printf_P>
    165e:	8c e2       	ldi	r24, 0x2C	; 44
    1660:	68 2e       	mov	r6, r24
    1662:	82 e0       	ldi	r24, 0x02	; 2
    1664:	78 2e       	mov	r7, r24
            for (uint8_t i = 0; i < rpt_count; i++) {
    1666:	0f b6       	in	r0, 0x3f	; 63
    1668:	f8 94       	cli
    166a:	de bf       	out	0x3e, r29	; 62
    166c:	0f be       	out	0x3f, r0	; 63
    166e:	cd bf       	out	0x3d, r28	; 61
    1670:	e1 2c       	mov	r14, r1
    1672:	f1 2c       	mov	r15, r1
                    // This path component has beeen
                    // repeated (used).
                    printf_P(PSTR("[%.6s-%d*] "), rpt_list[i].call, rpt_list[i].ssid);
                } else {
                    // Not yet repeated
                    printf_P(PSTR("[%.6s-%d] "), rpt_list[i].call, rpt_list[i].ssid);
    1674:	97 e3       	ldi	r25, 0x37	; 55
    1676:	a9 2e       	mov	r10, r25
    1678:	93 e0       	ldi	r25, 0x03	; 3
    167a:	b9 2e       	mov	r11, r25
            printf_P(PSTR("\nRXd Path (%d): "), rpt_count);
            for (uint8_t i = 0; i < rpt_count; i++) {
                if ((rpt_hbits >> i) & 0x01) {
                    // This path component has beeen
                    // repeated (used).
                    printf_P(PSTR("[%.6s-%d*] "), rpt_list[i].call, rpt_list[i].ssid);
    167c:	22 e4       	ldi	r18, 0x42	; 66
    167e:	82 2e       	mov	r8, r18
    1680:	23 e0       	ldi	r18, 0x03	; 3
    1682:	92 2e       	mov	r9, r18

        #if SERIAL_DEBUG
            printf_P(PSTR("SRC[%.6s-%d] "), src.call, src.ssid);
            printf_P(PSTR("DST[%.6s-%d] "), dst.call, dst.ssid);
            printf_P(PSTR("\nRXd Path (%d): "), rpt_count);
            for (uint8_t i = 0; i < rpt_count; i++) {
    1684:	e4 14       	cp	r14, r4
    1686:	70 f5       	brcc	.+92     	; 0x16e4 <digipeater_processPackets+0x3ec>
                if ((rpt_hbits >> i) & 0x01) {
    1688:	80 91 0f 02 	lds	r24, 0x020F
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	0e 2c       	mov	r0, r14
    1690:	02 c0       	rjmp	.+4      	; 0x1696 <digipeater_processPackets+0x39e>
    1692:	95 95       	asr	r25
    1694:	87 95       	ror	r24
    1696:	0a 94       	dec	r0
    1698:	e2 f7       	brpl	.-8      	; 0x1692 <digipeater_processPackets+0x39a>
    169a:	80 ff       	sbrs	r24, 0
    169c:	09 c0       	rjmp	.+18     	; 0x16b0 <digipeater_processPackets+0x3b8>
                    // This path component has beeen
                    // repeated (used).
                    printf_P(PSTR("[%.6s-%d*] "), rpt_list[i].call, rpt_list[i].ssid);
    169e:	d3 01       	movw	r26, r6
    16a0:	8c 91       	ld	r24, X
    16a2:	1f 92       	push	r1
    16a4:	8f 93       	push	r24
    16a6:	3f 92       	push	r3
    16a8:	2f 92       	push	r2
    16aa:	9f 92       	push	r9
    16ac:	8f 92       	push	r8
    16ae:	08 c0       	rjmp	.+16     	; 0x16c0 <digipeater_processPackets+0x3c8>
                } else {
                    // Not yet repeated
                    printf_P(PSTR("[%.6s-%d] "), rpt_list[i].call, rpt_list[i].ssid);
    16b0:	f3 01       	movw	r30, r6
    16b2:	80 81       	ld	r24, Z
    16b4:	1f 92       	push	r1
    16b6:	8f 93       	push	r24
    16b8:	3f 92       	push	r3
    16ba:	2f 92       	push	r2
    16bc:	bf 92       	push	r11
    16be:	af 92       	push	r10
    16c0:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <printf_P>
    16c4:	0f 90       	pop	r0
    16c6:	0f 90       	pop	r0
    16c8:	0f 90       	pop	r0
    16ca:	0f 90       	pop	r0
    16cc:	0f 90       	pop	r0
    16ce:	0f 90       	pop	r0
    16d0:	ff ef       	ldi	r31, 0xFF	; 255
    16d2:	ef 1a       	sub	r14, r31
    16d4:	ff 0a       	sbc	r15, r31
    16d6:	27 e0       	ldi	r18, 0x07	; 7
    16d8:	62 0e       	add	r6, r18
    16da:	71 1c       	adc	r7, r1
    16dc:	37 e0       	ldi	r19, 0x07	; 7
    16de:	23 0e       	add	r2, r19
    16e0:	31 1c       	adc	r3, r1
    16e2:	d0 cf       	rjmp	.-96     	; 0x1684 <digipeater_processPackets+0x38c>
                }
            }
	    printf_P(PSTR("\n"));
    16e4:	85 e3       	ldi	r24, 0x35	; 53
    16e6:	93 e0       	ldi	r25, 0x03	; 3
    16e8:	9f 93       	push	r25
    16ea:	8f 93       	push	r24
    16ec:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <printf_P>
            if (repeat && !unrelated) {
    16f0:	0f 90       	pop	r0
    16f2:	0f 90       	pop	r0
    16f4:	55 20       	and	r5, r5
    16f6:	09 f4       	brne	.+2      	; 0x16fa <digipeater_processPackets+0x402>
    16f8:	64 c0       	rjmp	.+200    	; 0x17c2 <digipeater_processPackets+0x4ca>
    16fa:	c1 10       	cpse	r12, r1
    16fc:	62 c0       	rjmp	.+196    	; 0x17c2 <digipeater_processPackets+0x4ca>
                printf("IGATE: @%.6s-%d>%.6s-%d", src.call, src.ssid, dst.call, dst.ssid);
    16fe:	80 e1       	ldi	r24, 0x10	; 16
    1700:	92 e0       	ldi	r25, 0x02	; 2
    1702:	20 91 16 02 	lds	r18, 0x0216
    1706:	1f 92       	push	r1
    1708:	2f 93       	push	r18
    170a:	9f 93       	push	r25
    170c:	8f 93       	push	r24
    170e:	8e e5       	ldi	r24, 0x5E	; 94
    1710:	92 e0       	ldi	r25, 0x02	; 2
    1712:	20 91 64 02 	lds	r18, 0x0264
    1716:	1f 92       	push	r1
    1718:	2f 93       	push	r18
    171a:	9f 93       	push	r25
    171c:	8f 93       	push	r24
    171e:	84 e2       	ldi	r24, 0x24	; 36
    1720:	91 e0       	ldi	r25, 0x01	; 1
    1722:	9f 93       	push	r25
    1724:	8f 93       	push	r24
    1726:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <printf>
    172a:	e1 ec       	ldi	r30, 0xC1	; 193
    172c:	4e 2e       	mov	r4, r30
    172e:	e3 e0       	ldi	r30, 0x03	; 3
    1730:	5e 2e       	mov	r5, r30
    1732:	fb eb       	ldi	r31, 0xBB	; 187
    1734:	ef 2e       	mov	r14, r31
    1736:	f3 e0       	ldi	r31, 0x03	; 3
    1738:	ff 2e       	mov	r15, r31

                for (uint8_t i = 0; i < rpt_count_out; i++) {
    173a:	0f b6       	in	r0, 0x3f	; 63
    173c:	f8 94       	cli
    173e:	de bf       	out	0x3e, r29	; 62
    1740:	0f be       	out	0x3f, r0	; 63
    1742:	cd bf       	out	0x3d, r28	; 61
    1744:	a1 2c       	mov	r10, r1
    1746:	b1 2c       	mov	r11, r1
                        // repeated (used).
                        printf_P(PSTR(",%.6s-%d*"), rpt_list_out[i].call, rpt_list_out[i].ssid);
                                                      } 
                     else {
                        // Not yet repeated
                        printf_P(PSTR(",%.6s-%d"), rpt_list_out[i].call, rpt_list_out[i].ssid);
    1748:	a2 e2       	ldi	r26, 0x22	; 34
    174a:	8a 2e       	mov	r8, r26
    174c:	a3 e0       	ldi	r26, 0x03	; 3
    174e:	9a 2e       	mov	r9, r26

                for (uint8_t i = 0; i < rpt_count_out; i++) {
                    if ((rpt_hbits_out >> i) & 0x01) {
                        // This path component has beeen
                        // repeated (used).
                        printf_P(PSTR(",%.6s-%d*"), rpt_list_out[i].call, rpt_list_out[i].ssid);
    1750:	bb e2       	ldi	r27, 0x2B	; 43
    1752:	6b 2e       	mov	r6, r27
    1754:	b3 e0       	ldi	r27, 0x03	; 3
    1756:	7b 2e       	mov	r7, r27
            }
	    printf_P(PSTR("\n"));
            if (repeat && !unrelated) {
                printf("IGATE: @%.6s-%d>%.6s-%d", src.call, src.ssid, dst.call, dst.ssid);

                for (uint8_t i = 0; i < rpt_count_out; i++) {
    1758:	ad 14       	cp	r10, r13
    175a:	70 f5       	brcc	.+92     	; 0x17b8 <digipeater_processPackets+0x4c0>
                    if ((rpt_hbits_out >> i) & 0x01) {
    175c:	80 91 17 02 	lds	r24, 0x0217
    1760:	90 e0       	ldi	r25, 0x00	; 0
    1762:	0a 2c       	mov	r0, r10
    1764:	02 c0       	rjmp	.+4      	; 0x176a <digipeater_processPackets+0x472>
    1766:	95 95       	asr	r25
    1768:	87 95       	ror	r24
    176a:	0a 94       	dec	r0
    176c:	e2 f7       	brpl	.-8      	; 0x1766 <digipeater_processPackets+0x46e>
    176e:	80 ff       	sbrs	r24, 0
    1770:	09 c0       	rjmp	.+18     	; 0x1784 <digipeater_processPackets+0x48c>
                        // This path component has beeen
                        // repeated (used).
                        printf_P(PSTR(",%.6s-%d*"), rpt_list_out[i].call, rpt_list_out[i].ssid);
    1772:	d2 01       	movw	r26, r4
    1774:	8c 91       	ld	r24, X
    1776:	1f 92       	push	r1
    1778:	8f 93       	push	r24
    177a:	ff 92       	push	r15
    177c:	ef 92       	push	r14
    177e:	7f 92       	push	r7
    1780:	6f 92       	push	r6
    1782:	08 c0       	rjmp	.+16     	; 0x1794 <digipeater_processPackets+0x49c>
                                                      } 
                     else {
                        // Not yet repeated
                        printf_P(PSTR(",%.6s-%d"), rpt_list_out[i].call, rpt_list_out[i].ssid);
    1784:	f2 01       	movw	r30, r4
    1786:	80 81       	ld	r24, Z
    1788:	1f 92       	push	r1
    178a:	8f 93       	push	r24
    178c:	ff 92       	push	r15
    178e:	ef 92       	push	r14
    1790:	9f 92       	push	r9
    1792:	8f 92       	push	r8
    1794:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <printf_P>
    1798:	0f 90       	pop	r0
    179a:	0f 90       	pop	r0
    179c:	0f 90       	pop	r0
    179e:	0f 90       	pop	r0
    17a0:	0f 90       	pop	r0
    17a2:	0f 90       	pop	r0
    17a4:	ff ef       	ldi	r31, 0xFF	; 255
    17a6:	af 1a       	sub	r10, r31
    17a8:	bf 0a       	sbc	r11, r31
    17aa:	27 e0       	ldi	r18, 0x07	; 7
    17ac:	42 0e       	add	r4, r18
    17ae:	51 1c       	adc	r5, r1
    17b0:	37 e0       	ldi	r19, 0x07	; 7
    17b2:	e3 0e       	add	r14, r19
    17b4:	f1 1c       	adc	r15, r1
    17b6:	d0 cf       	rjmp	.-96     	; 0x1758 <digipeater_processPackets+0x460>
           	          }
                      }    
                printf(":");
    17b8:	8a e3       	ldi	r24, 0x3A	; 58
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <putchar>
    17c0:	0d c0       	rjmp	.+26     	; 0x17dc <digipeater_processPackets+0x4e4>
            } else {
                printf_P(PSTR("\nNot digipeating\n"));
    17c2:	80 e1       	ldi	r24, 0x10	; 16
    17c4:	93 e0       	ldi	r25, 0x03	; 3
    17c6:	9f 93       	push	r25
    17c8:	8f 93       	push	r24
    17ca:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <printf_P>
            }
        #endif

        if (repeat && !unrelated) {
    17ce:	0f 90       	pop	r0
    17d0:	0f 90       	pop	r0
    17d2:	55 20       	and	r5, r5
    17d4:	09 f4       	brne	.+2      	; 0x17d8 <digipeater_processPackets+0x4e0>
    17d6:	8d c1       	rjmp	.+794    	; 0x1af2 <digipeater_processPackets+0x7fa>
    17d8:	c1 10       	cpse	r12, r1
    17da:	8b c1       	rjmp	.+790    	; 0x1af2 <digipeater_processPackets+0x7fa>
            // Calculate payload length
            int payloadLength = frame_len - (buf - bufStart);
    17dc:	85 ef       	ldi	r24, 0xF5	; 245
    17de:	93 e0       	ldi	r25, 0x03	; 3
    17e0:	4c 01       	movw	r8, r24
    17e2:	80 1a       	sub	r8, r16
    17e4:	91 0a       	sbc	r9, r17
    17e6:	80 91 6f 07 	lds	r24, 0x076F
    17ea:	90 91 70 07 	lds	r25, 0x0770
    17ee:	88 0e       	add	r8, r24
    17f0:	99 1e       	adc	r9, r25
            //printf_P(PSTR("Payload length: %d"), payloadLength);

            // Init outgoing buffer to all zeroes
            memset(packetBufferOut, 0, AX25_MAX_FRAME_LEN);
    17f2:	8a e4       	ldi	r24, 0x4A	; 74
    17f4:	91 e0       	ldi	r25, 0x01	; 1
    17f6:	e5 e2       	ldi	r30, 0x25	; 37
    17f8:	f6 e0       	ldi	r31, 0x06	; 6
    17fa:	df 01       	movw	r26, r30
    17fc:	9c 01       	movw	r18, r24
    17fe:	1d 92       	st	X+, r1
    1800:	21 50       	subi	r18, 0x01	; 1
    1802:	30 40       	sbci	r19, 0x00	; 0
    1804:	e1 f7       	brne	.-8      	; 0x17fe <digipeater_processPackets+0x506>

            // We need to calculate a CRC checksum for
            // the src, dst and information fields only,
            // used to check for duplicates.
            ax25ctx->crc_out = CRC_CCIT_INIT_VAL;
    1806:	a0 91 3f 05 	lds	r26, 0x053F
    180a:	b0 91 40 05 	lds	r27, 0x0540
    180e:	a0 5b       	subi	r26, 0xB0	; 176
    1810:	be 4f       	sbci	r27, 0xFE	; 254
    1812:	8f ef       	ldi	r24, 0xFF	; 255
    1814:	9f ef       	ldi	r25, 0xFF	; 255
    1816:	11 96       	adiw	r26, 0x01	; 1
    1818:	9c 93       	st	X, r25
    181a:	8e 93       	st	-X, r24
    181c:	20 91 23 06 	lds	r18, 0x0623
    1820:	30 91 24 06 	lds	r19, 0x0624
    1824:	a9 01       	movw	r20, r18
    1826:	4b 5d       	subi	r20, 0xDB	; 219
    1828:	59 4f       	sbci	r21, 0xF9	; 249
    182a:	5a 01       	movw	r10, r20

            char c;

            // Add destination address
            for (unsigned i = 0; i < sizeof(dst.call); i++) {
                c = dst.call[i];
    182c:	ea 85       	ldd	r30, Y+10	; 0x0a
    182e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1830:	61 91       	ld	r22, Z+
    1832:	fb 87       	std	Y+11, r31	; 0x0b
    1834:	ea 87       	std	Y+10, r30	; 0x0a
                if (c == '\x0') c = ' ';
    1836:	61 11       	cpse	r22, r1
    1838:	01 c0       	rjmp	.+2      	; 0x183c <digipeater_processPackets+0x544>
    183a:	60 e2       	ldi	r22, 0x20	; 32
                c = c << 1;
    183c:	66 0f       	add	r22, r22
                packetBufferOut[frame_len_out++] = c;
    183e:	fa 01       	movw	r30, r20
    1840:	61 93       	st	Z+, r22
    1842:	af 01       	movw	r20, r30
    1844:	fc 01       	movw	r30, r24
    1846:	e6 27       	eor	r30, r22
    1848:	ff 27       	eor	r31, r31
    184a:	ee 0f       	add	r30, r30
    184c:	ff 1f       	adc	r31, r31
    184e:	e8 51       	subi	r30, 0x18	; 24
    1850:	ff 4f       	sbci	r31, 0xFF	; 255
    1852:	e5 90       	lpm	r14, Z+
    1854:	f4 90       	lpm	r15, Z
    1856:	89 2f       	mov	r24, r25
    1858:	99 27       	eor	r25, r25
    185a:	8e 25       	eor	r24, r14
    185c:	9f 25       	eor	r25, r15
            ax25ctx->crc_out = CRC_CCIT_INIT_VAL;

            char c;

            // Add destination address
            for (unsigned i = 0; i < sizeof(dst.call); i++) {
    185e:	6a 85       	ldd	r22, Y+10	; 0x0a
    1860:	7b 85       	ldd	r23, Y+11	; 0x0b
    1862:	66 51       	subi	r22, 0x16	; 22
    1864:	72 40       	sbci	r23, 0x02	; 2
    1866:	11 f7       	brne	.-60     	; 0x182c <digipeater_processPackets+0x534>
    1868:	11 96       	adiw	r26, 0x01	; 1
    186a:	9c 93       	st	X, r25
    186c:	8e 93       	st	-X, r24
                c = c << 1;
                packetBufferOut[frame_len_out++] = c;
                // Update CRC
                ax25ctx->crc_out = update_crc_ccit(c, ax25ctx->crc_out);
            }
            packetBufferOut[frame_len_out++] = 0x60 | (src.ssid << 1);
    186e:	29 5f       	subi	r18, 0xF9	; 249
    1870:	3f 4f       	sbci	r19, 0xFF	; 255
    1872:	c0 90 64 02 	lds	r12, 0x0264
    1876:	4c 2d       	mov	r20, r12
    1878:	44 0f       	add	r20, r20
    187a:	40 66       	ori	r20, 0x60	; 96
    187c:	c4 2e       	mov	r12, r20
    187e:	f5 01       	movw	r30, r10
    1880:	46 83       	std	Z+6, r20	; 0x06
    1882:	a9 01       	movw	r20, r18
    1884:	4b 5d       	subi	r20, 0xDB	; 219
    1886:	59 4f       	sbci	r21, 0xF9	; 249
    1888:	5a 01       	movw	r10, r20

            // Add source address
            for (unsigned i = 0; i < sizeof(src.call); i++) {
                c = src.call[i];
    188a:	e8 85       	ldd	r30, Y+8	; 0x08
    188c:	f9 85       	ldd	r31, Y+9	; 0x09
    188e:	61 91       	ld	r22, Z+
    1890:	f9 87       	std	Y+9, r31	; 0x09
    1892:	e8 87       	std	Y+8, r30	; 0x08
                if (c == '\x0') c = ' ';
    1894:	61 11       	cpse	r22, r1
    1896:	01 c0       	rjmp	.+2      	; 0x189a <digipeater_processPackets+0x5a2>
    1898:	60 e2       	ldi	r22, 0x20	; 32
                c = c << 1;
    189a:	66 0f       	add	r22, r22
                packetBufferOut[frame_len_out++] = c;
    189c:	fa 01       	movw	r30, r20
    189e:	61 93       	st	Z+, r22
    18a0:	af 01       	movw	r20, r30
    18a2:	fc 01       	movw	r30, r24
    18a4:	e6 27       	eor	r30, r22
    18a6:	ff 27       	eor	r31, r31
    18a8:	ee 0f       	add	r30, r30
    18aa:	ff 1f       	adc	r31, r31
    18ac:	e8 51       	subi	r30, 0x18	; 24
    18ae:	ff 4f       	sbci	r31, 0xFF	; 255
    18b0:	e5 90       	lpm	r14, Z+
    18b2:	f4 90       	lpm	r15, Z
    18b4:	89 2f       	mov	r24, r25
    18b6:	99 27       	eor	r25, r25
    18b8:	8e 25       	eor	r24, r14
    18ba:	9f 25       	eor	r25, r15
                ax25ctx->crc_out = update_crc_ccit(c, ax25ctx->crc_out);
            }
            packetBufferOut[frame_len_out++] = 0x60 | (src.ssid << 1);

            // Add source address
            for (unsigned i = 0; i < sizeof(src.call); i++) {
    18bc:	68 85       	ldd	r22, Y+8	; 0x08
    18be:	79 85       	ldd	r23, Y+9	; 0x09
    18c0:	64 56       	subi	r22, 0x64	; 100
    18c2:	72 40       	sbci	r23, 0x02	; 2
    18c4:	11 f7       	brne	.-60     	; 0x188a <digipeater_processPackets+0x592>
    18c6:	8d 93       	st	X+, r24
    18c8:	9c 93       	st	X, r25
                c = c << 1;
                packetBufferOut[frame_len_out++] = c;
                // Update CRC
                ax25ctx->crc_out = update_crc_ccit(c, ax25ctx->crc_out);
            }
            packetBufferOut[frame_len_out++] = 0x60 | (src.ssid << 1);
    18ca:	29 5f       	subi	r18, 0xF9	; 249
    18cc:	3f 4f       	sbci	r19, 0xFF	; 255
    18ce:	30 93 24 06 	sts	0x0624, r19
    18d2:	20 93 23 06 	sts	0x0623, r18
    18d6:	d5 01       	movw	r26, r10
    18d8:	16 96       	adiw	r26, 0x06	; 6
    18da:	cc 92       	st	X, r12
    18dc:	8b eb       	ldi	r24, 0xBB	; 187
    18de:	e8 2e       	mov	r14, r24
    18e0:	83 e0       	ldi	r24, 0x03	; 3
    18e2:	f8 2e       	mov	r15, r24

            // Add path
            for (int i = 0; i < rpt_count_out; i++) {
    18e4:	40 e0       	ldi	r20, 0x00	; 0
    18e6:	50 e0       	ldi	r21, 0x00	; 0
    18e8:	8d 2d       	mov	r24, r13
    18ea:	90 e0       	ldi	r25, 0x00	; 0
                AX25Call p = rpt_list_out[i];
    18ec:	27 e0       	ldi	r18, 0x07	; 7
    18ee:	72 2e       	mov	r7, r18
    18f0:	5e 01       	movw	r10, r28
    18f2:	b7 e0       	ldi	r27, 0x07	; 7
    18f4:	ab 0e       	add	r10, r27
    18f6:	b1 1c       	adc	r11, r1
                    c = p.call[i];
                    if (c == '\x0') c = ' ';
                    c = c << 1;
                    packetBufferOut[frame_len_out++] = c;
                }
                packetBufferOut[frame_len_out++] = 0x60 | (p.ssid << 1) | (set_hbit ? 0x80 : 0x00) | (i == rpt_count_out-1 ? 0x01 : 0);
    18f8:	6c 01       	movw	r12, r24
    18fa:	e1 e0       	ldi	r30, 0x01	; 1
    18fc:	ce 1a       	sub	r12, r30
    18fe:	d1 08       	sbc	r13, r1
                ax25ctx->crc_out = update_crc_ccit(c, ax25ctx->crc_out);
            }
            packetBufferOut[frame_len_out++] = 0x60 | (src.ssid << 1);

            // Add path
            for (int i = 0; i < rpt_count_out; i++) {
    1900:	48 17       	cp	r20, r24
    1902:	59 07       	cpc	r21, r25
    1904:	0c f0       	brlt	.+2      	; 0x1908 <digipeater_processPackets+0x610>
    1906:	4c c0       	rjmp	.+152    	; 0x19a0 <digipeater_processPackets+0x6a8>
                AX25Call p = rpt_list_out[i];
    1908:	f7 01       	movw	r30, r14
    190a:	de 01       	movw	r26, r28
    190c:	11 96       	adiw	r26, 0x01	; 1
    190e:	27 2d       	mov	r18, r7
    1910:	01 90       	ld	r0, Z+
    1912:	0d 92       	st	X+, r0
    1914:	2a 95       	dec	r18
    1916:	e1 f7       	brne	.-8      	; 0x1910 <digipeater_processPackets+0x618>
    1918:	d7 01       	movw	r26, r14
    191a:	16 96       	adiw	r26, 0x06	; 6
    191c:	6c 90       	ld	r6, X
                bool set_hbit = false;
                if ((rpt_hbits_out >> i) & 0x01) set_hbit = true;
    191e:	20 91 17 02 	lds	r18, 0x0217
    1922:	30 e0       	ldi	r19, 0x00	; 0
    1924:	04 2e       	mov	r0, r20
    1926:	02 c0       	rjmp	.+4      	; 0x192c <digipeater_processPackets+0x634>
    1928:	35 95       	asr	r19
    192a:	27 95       	ror	r18
    192c:	0a 94       	dec	r0
    192e:	e2 f7       	brpl	.-8      	; 0x1928 <digipeater_processPackets+0x630>
    1930:	21 70       	andi	r18, 0x01	; 1
    1932:	33 27       	eor	r19, r19
    1934:	60 91 23 06 	lds	r22, 0x0623
    1938:	70 91 24 06 	lds	r23, 0x0624
    193c:	fe 01       	movw	r30, r28
    193e:	31 96       	adiw	r30, 0x01	; 1
    1940:	db 01       	movw	r26, r22
    1942:	ab 5d       	subi	r26, 0xDB	; 219
    1944:	b9 4f       	sbci	r27, 0xF9	; 249
                for (unsigned i = 0; i < sizeof(p.call); i++) {
                    c = p.call[i];
    1946:	51 90       	ld	r5, Z+
                    if (c == '\x0') c = ' ';
    1948:	51 10       	cpse	r5, r1
    194a:	03 c0       	rjmp	.+6      	; 0x1952 <digipeater_processPackets+0x65a>
    194c:	68 94       	set
    194e:	55 24       	eor	r5, r5
    1950:	55 f8       	bld	r5, 5
                    c = c << 1;
    1952:	55 0c       	add	r5, r5
                    packetBufferOut[frame_len_out++] = c;
    1954:	5d 92       	st	X+, r5
            // Add path
            for (int i = 0; i < rpt_count_out; i++) {
                AX25Call p = rpt_list_out[i];
                bool set_hbit = false;
                if ((rpt_hbits_out >> i) & 0x01) set_hbit = true;
                for (unsigned i = 0; i < sizeof(p.call); i++) {
    1956:	ea 15       	cp	r30, r10
    1958:	fb 05       	cpc	r31, r11
    195a:	a9 f7       	brne	.-22     	; 0x1946 <digipeater_processPackets+0x64e>
    195c:	fb 01       	movw	r30, r22
    195e:	36 96       	adiw	r30, 0x06	; 6
                    c = p.call[i];
                    if (c == '\x0') c = ' ';
                    c = c << 1;
                    packetBufferOut[frame_len_out++] = c;
                }
                packetBufferOut[frame_len_out++] = 0x60 | (p.ssid << 1) | (set_hbit ? 0x80 : 0x00) | (i == rpt_count_out-1 ? 0x01 : 0);
    1960:	69 5f       	subi	r22, 0xF9	; 249
    1962:	7f 4f       	sbci	r23, 0xFF	; 255
    1964:	70 93 24 06 	sts	0x0624, r23
    1968:	60 93 23 06 	sts	0x0623, r22
    196c:	66 2d       	mov	r22, r6
    196e:	70 e0       	ldi	r23, 0x00	; 0
    1970:	66 0f       	add	r22, r22
    1972:	77 1f       	adc	r23, r23
    1974:	23 2b       	or	r18, r19
    1976:	11 f4       	brne	.+4      	; 0x197c <digipeater_processPackets+0x684>
    1978:	20 e0       	ldi	r18, 0x00	; 0
    197a:	01 c0       	rjmp	.+2      	; 0x197e <digipeater_processPackets+0x686>
    197c:	20 e8       	ldi	r18, 0x80	; 128
    197e:	eb 5d       	subi	r30, 0xDB	; 219
    1980:	f9 4f       	sbci	r31, 0xF9	; 249
    1982:	31 e0       	ldi	r19, 0x01	; 1
    1984:	4c 15       	cp	r20, r12
    1986:	5d 05       	cpc	r21, r13
    1988:	09 f0       	breq	.+2      	; 0x198c <digipeater_processPackets+0x694>
    198a:	30 e0       	ldi	r19, 0x00	; 0
    198c:	30 66       	ori	r19, 0x60	; 96
    198e:	63 2b       	or	r22, r19
    1990:	26 2b       	or	r18, r22
    1992:	20 83       	st	Z, r18
                ax25ctx->crc_out = update_crc_ccit(c, ax25ctx->crc_out);
            }
            packetBufferOut[frame_len_out++] = 0x60 | (src.ssid << 1);

            // Add path
            for (int i = 0; i < rpt_count_out; i++) {
    1994:	4f 5f       	subi	r20, 0xFF	; 255
    1996:	5f 4f       	sbci	r21, 0xFF	; 255
    1998:	b7 e0       	ldi	r27, 0x07	; 7
    199a:	eb 0e       	add	r14, r27
    199c:	f1 1c       	adc	r15, r1
    199e:	b0 cf       	rjmp	.-160    	; 0x1900 <digipeater_processPackets+0x608>
                    packetBufferOut[frame_len_out++] = c;
                }
                packetBufferOut[frame_len_out++] = 0x60 | (p.ssid << 1) | (set_hbit ? 0x80 : 0x00) | (i == rpt_count_out-1 ? 0x01 : 0);
            }

            packetBufferOut[frame_len_out++] = AX25_CTRL_UI;
    19a0:	80 91 23 06 	lds	r24, 0x0623
    19a4:	90 91 24 06 	lds	r25, 0x0624
    19a8:	fc 01       	movw	r30, r24
    19aa:	eb 5d       	subi	r30, 0xDB	; 219
    19ac:	f9 4f       	sbci	r31, 0xF9	; 249
    19ae:	23 e0       	ldi	r18, 0x03	; 3
    19b0:	20 83       	st	Z, r18
            packetBufferOut[frame_len_out++] = AX25_PID_NOLAYER3;
    19b2:	02 96       	adiw	r24, 0x02	; 2
    19b4:	90 93 24 06 	sts	0x0624, r25
    19b8:	80 93 23 06 	sts	0x0623, r24
    19bc:	80 ef       	ldi	r24, 0xF0	; 240
    19be:	81 83       	std	Z+1, r24	; 0x01

            // Add payload
            for (int i = 0; i < payloadLength-2; i++) {
    19c0:	e1 2c       	mov	r14, r1
    19c2:	f1 2c       	mov	r15, r1
    19c4:	e2 e0       	ldi	r30, 0x02	; 2
    19c6:	8e 1a       	sub	r8, r30
    19c8:	91 08       	sbc	r9, r1
    19ca:	e8 14       	cp	r14, r8
    19cc:	f9 04       	cpc	r15, r9
    19ce:	0c f0       	brlt	.+2      	; 0x19d2 <digipeater_processPackets+0x6da>
    19d0:	3b c0       	rjmp	.+118    	; 0x1a48 <digipeater_processPackets+0x750>
                if (i > 1) {
    19d2:	f2 e0       	ldi	r31, 0x02	; 2
    19d4:	ef 16       	cp	r14, r31
    19d6:	f1 04       	cpc	r15, r1
    19d8:	8c f1       	brlt	.+98     	; 0x1a3c <digipeater_processPackets+0x744>
                    packetBufferOut[frame_len_out++] = buf[i];
    19da:	20 91 23 06 	lds	r18, 0x0623
    19de:	30 91 24 06 	lds	r19, 0x0624
    19e2:	c9 01       	movw	r24, r18
    19e4:	01 96       	adiw	r24, 0x01	; 1
    19e6:	90 93 24 06 	sts	0x0624, r25
    19ea:	80 93 23 06 	sts	0x0623, r24
    19ee:	d8 01       	movw	r26, r16
    19f0:	8c 91       	ld	r24, X
    19f2:	f9 01       	movw	r30, r18
    19f4:	eb 5d       	subi	r30, 0xDB	; 219
    19f6:	f9 4f       	sbci	r31, 0xF9	; 249
    19f8:	80 83       	st	Z, r24
                #if SERIAL_DEBUG
		    putchar(buf[i]);
    19fa:	60 91 73 07 	lds	r22, 0x0773
    19fe:	70 91 74 07 	lds	r23, 0x0774
    1a02:	90 e0       	ldi	r25, 0x00	; 0
    1a04:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
                #endif
                    // Update CRC
                    ax25ctx->crc_out = update_crc_ccit(buf[i], ax25ctx->crc_out);
    1a08:	a0 91 3f 05 	lds	r26, 0x053F
    1a0c:	b0 91 40 05 	lds	r27, 0x0540
    1a10:	a0 5b       	subi	r26, 0xB0	; 176
    1a12:	be 4f       	sbci	r27, 0xFE	; 254
    1a14:	8d 91       	ld	r24, X+
    1a16:	9c 91       	ld	r25, X
    1a18:	11 97       	sbiw	r26, 0x01	; 1
    1a1a:	f8 01       	movw	r30, r16
    1a1c:	20 81       	ld	r18, Z
    1a1e:	fc 01       	movw	r30, r24
    1a20:	e2 27       	eor	r30, r18
    1a22:	ff 27       	eor	r31, r31
    1a24:	ee 0f       	add	r30, r30
    1a26:	ff 1f       	adc	r31, r31
    1a28:	e8 51       	subi	r30, 0x18	; 24
    1a2a:	ff 4f       	sbci	r31, 0xFF	; 255
    1a2c:	25 91       	lpm	r18, Z+
    1a2e:	34 91       	lpm	r19, Z
    1a30:	89 2f       	mov	r24, r25
    1a32:	99 27       	eor	r25, r25
    1a34:	82 27       	eor	r24, r18
    1a36:	93 27       	eor	r25, r19
    1a38:	8d 93       	st	X+, r24
    1a3a:	9c 93       	st	X, r25

            packetBufferOut[frame_len_out++] = AX25_CTRL_UI;
            packetBufferOut[frame_len_out++] = AX25_PID_NOLAYER3;

            // Add payload
            for (int i = 0; i < payloadLength-2; i++) {
    1a3c:	ff ef       	ldi	r31, 0xFF	; 255
    1a3e:	ef 1a       	sub	r14, r31
    1a40:	ff 0a       	sbc	r15, r31
    1a42:	0f 5f       	subi	r16, 0xFF	; 255
    1a44:	1f 4f       	sbci	r17, 0xFF	; 255
    1a46:	c1 cf       	rjmp	.-126    	; 0x19ca <digipeater_processPackets+0x6d2>
                #endif
                    // Update CRC
                    ax25ctx->crc_out = update_crc_ccit(buf[i], ax25ctx->crc_out);
                }
            }
            uint8_t crcl = (ax25ctx->crc_out & 0xff) ^ 0xff;
    1a48:	e0 91 3f 05 	lds	r30, 0x053F
    1a4c:	f0 91 40 05 	lds	r31, 0x0540
    1a50:	e0 5b       	subi	r30, 0xB0	; 176
    1a52:	fe 4f       	sbci	r31, 0xFE	; 254
    1a54:	00 81       	ld	r16, Z
    1a56:	11 81       	ldd	r17, Z+1	; 0x01
    1a58:	00 95       	com	r16
            uint8_t crch = (ax25ctx->crc_out >> 8) ^ 0xff;
    1a5a:	10 95       	com	r17

            if (!is_duplicate(crcl, crch)) {
    1a5c:	61 2f       	mov	r22, r17
    1a5e:	80 2f       	mov	r24, r16
    1a60:	0e 94 9e 08 	call	0x113c	; 0x113c <is_duplicate>
    1a64:	81 11       	cpse	r24, r1
    1a66:	3d c0       	rjmp	.+122    	; 0x1ae2 <digipeater_processPackets+0x7ea>
                // Send it out!
                #if SERIAL_DEBUG
                  printf_P(PSTR("\n"));
    1a68:	8e e0       	ldi	r24, 0x0E	; 14
    1a6a:	93 e0       	ldi	r25, 0x03	; 3
    1a6c:	9f 93       	push	r25
    1a6e:	8f 93       	push	r24
    1a70:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <printf_P>
                #endif
                digipeater_csma(ax25ctx, packetBufferOut, frame_len_out);
    1a74:	40 91 23 06 	lds	r20, 0x0623
    1a78:	50 91 24 06 	lds	r21, 0x0624
    1a7c:	65 e2       	ldi	r22, 0x25	; 37
    1a7e:	76 e0       	ldi	r23, 0x06	; 6
    1a80:	80 91 3f 05 	lds	r24, 0x053F
    1a84:	90 91 40 05 	lds	r25, 0x0540
    1a88:	0e 94 fe 08 	call	0x11fc	; 0x11fc <digipeater_csma>

                // Add packet to duplicate checklist
                dupl_list[dupl_i].crcl = crcl;
    1a8c:	e0 91 3e 01 	lds	r30, 0x013E
    1a90:	27 e0       	ldi	r18, 0x07	; 7
    1a92:	2e 9f       	mul	r18, r30
    1a94:	f0 01       	movw	r30, r0
    1a96:	11 24       	eor	r1, r1
    1a98:	ed 5b       	subi	r30, 0xBD	; 189
    1a9a:	fa 4f       	sbci	r31, 0xFA	; 250
    1a9c:	01 83       	std	Z+1, r16	; 0x01
                dupl_list[dupl_i].crch = crch;
    1a9e:	12 83       	std	Z+2, r17	; 0x02
volatile ticks_t _clock;

inline ticks_t timer_clock(void) {
    ticks_t result;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1aa0:	3f b7       	in	r19, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1aa2:	f8 94       	cli
        result = _clock;
    1aa4:	80 91 0b 02 	lds	r24, 0x020B
    1aa8:	90 91 0c 02 	lds	r25, 0x020C
    1aac:	a0 91 0d 02 	lds	r26, 0x020D
    1ab0:	b0 91 0e 02 	lds	r27, 0x020E
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1ab4:	3f bf       	out	0x3f, r19	; 63
                dupl_list[dupl_i].timestamp = timer_clock();
    1ab6:	83 83       	std	Z+3, r24	; 0x03
    1ab8:	94 83       	std	Z+4, r25	; 0x04
    1aba:	a5 83       	std	Z+5, r26	; 0x05
    1abc:	b6 83       	std	Z+6, r27	; 0x06
                dupl_list[dupl_i].active = true;
    1abe:	80 91 3e 01 	lds	r24, 0x013E
    1ac2:	90 e0       	ldi	r25, 0x00	; 0
    1ac4:	28 9f       	mul	r18, r24
    1ac6:	f0 01       	movw	r30, r0
    1ac8:	29 9f       	mul	r18, r25
    1aca:	f0 0d       	add	r31, r0
    1acc:	11 24       	eor	r1, r1
    1ace:	ed 5b       	subi	r30, 0xBD	; 189
    1ad0:	fa 4f       	sbci	r31, 0xFA	; 250
    1ad2:	21 e0       	ldi	r18, 0x01	; 1
    1ad4:	20 83       	st	Z, r18
                dupl_i = (dupl_i + 1) % DUPL_LIST_SIZE;
    1ad6:	01 96       	adiw	r24, 0x01	; 1
    1ad8:	8f 71       	andi	r24, 0x1F	; 31
    1ada:	99 27       	eor	r25, r25
    1adc:	80 93 3e 01 	sts	0x013E, r24
    1ae0:	06 c0       	rjmp	.+12     	; 0x1aee <digipeater_processPackets+0x7f6>
            } else {
                #if SERIAL_DEBUG
                    printf_P(PSTR("Duplicate detected, dropping packet\n\n"));
    1ae2:	88 ee       	ldi	r24, 0xE8	; 232
    1ae4:	92 e0       	ldi	r25, 0x02	; 2
    1ae6:	9f 93       	push	r25
    1ae8:	8f 93       	push	r24
    1aea:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <printf_P>
    1aee:	0f 90       	pop	r0
    1af0:	0f 90       	pop	r0
                #endif
            }
        }

        // Reset frame_len to 0
        frame_len = 0;
    1af2:	10 92 70 07 	sts	0x0770, r1
    1af6:	10 92 6f 07 	sts	0x076F, r1
        rpt_hbits_out = 0x00;
    1afa:	10 92 17 02 	sts	0x0217, r1
    }
}
    1afe:	2e 96       	adiw	r28, 0x0e	; 14
    1b00:	0f b6       	in	r0, 0x3f	; 63
    1b02:	f8 94       	cli
    1b04:	de bf       	out	0x3e, r29	; 62
    1b06:	0f be       	out	0x3f, r0	; 63
    1b08:	cd bf       	out	0x3d, r28	; 61
    1b0a:	df 91       	pop	r29
    1b0c:	cf 91       	pop	r28
    1b0e:	1f 91       	pop	r17
    1b10:	0f 91       	pop	r16
    1b12:	ff 90       	pop	r15
    1b14:	ef 90       	pop	r14
    1b16:	df 90       	pop	r13
    1b18:	cf 90       	pop	r12
    1b1a:	bf 90       	pop	r11
    1b1c:	af 90       	pop	r10
    1b1e:	9f 90       	pop	r9
    1b20:	8f 90       	pop	r8
    1b22:	7f 90       	pop	r7
    1b24:	6f 90       	pop	r6
    1b26:	5f 90       	pop	r5
    1b28:	4f 90       	pop	r4
    1b2a:	3f 90       	pop	r3
    1b2c:	2f 90       	pop	r2
    1b2e:	08 95       	ret

00001b30 <digipeater_messageCallback>:
    1b30:	20 91 6f 07 	lds	r18, 0x076F
    1b34:	30 91 70 07 	lds	r19, 0x0770
    1b38:	23 2b       	or	r18, r19
    1b3a:	b9 f4       	brne	.+46     	; 0x1b6a <digipeater_messageCallback+0x3a>
    1b3c:	f8 94       	cli
    1b3e:	fc 01       	movw	r30, r24
    1b40:	e4 5b       	subi	r30, 0xB4	; 180
    1b42:	fe 4f       	sbci	r31, 0xFE	; 254
    1b44:	20 81       	ld	r18, Z
    1b46:	31 81       	ldd	r19, Z+1	; 0x01
    1b48:	fc 01       	movw	r30, r24
    1b4a:	a5 ef       	ldi	r26, 0xF5	; 245
    1b4c:	b3 e0       	ldi	r27, 0x03	; 3
    1b4e:	cd 01       	movw	r24, r26
    1b50:	85 5f       	subi	r24, 0xF5	; 245
    1b52:	93 40       	sbci	r25, 0x03	; 3
    1b54:	82 17       	cp	r24, r18
    1b56:	93 07       	cpc	r25, r19
    1b58:	18 f4       	brcc	.+6      	; 0x1b60 <digipeater_messageCallback+0x30>
    1b5a:	81 91       	ld	r24, Z+
    1b5c:	8d 93       	st	X+, r24
    1b5e:	f7 cf       	rjmp	.-18     	; 0x1b4e <digipeater_messageCallback+0x1e>
    1b60:	30 93 70 07 	sts	0x0770, r19
    1b64:	20 93 6f 07 	sts	0x076F, r18
    1b68:	78 94       	sei
    1b6a:	08 95       	ret

00001b6c <main>:

}

int main (void) {
    init();
    1b6c:	0e 94 df 01 	call	0x3be	; 0x3be <init>

    while (true) {
        ax25_poll(&AX25);
    1b70:	85 e6       	ldi	r24, 0x65	; 101
    1b72:	92 e0       	ldi	r25, 0x02	; 2
    1b74:	0e 94 a9 07 	call	0xf52	; 0xf52 <ax25_poll>
        digipeater_processPackets();
    1b78:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <digipeater_processPackets>
        
        if (serial_available(0)) {
    1b7c:	80 e0       	ldi	r24, 0x00	; 0
    1b7e:	0e 94 50 02 	call	0x4a0	; 0x4a0 <serial_available>
            //char sbyte = uart0_getchar_nowait();
            // Do something with the data :)
        }
    }
    1b82:	f6 cf       	rjmp	.-20     	; 0x1b70 <main+0x4>

00001b84 <__udivmodsi4>:
    1b84:	a1 e2       	ldi	r26, 0x21	; 33
    1b86:	1a 2e       	mov	r1, r26
    1b88:	aa 1b       	sub	r26, r26
    1b8a:	bb 1b       	sub	r27, r27
    1b8c:	fd 01       	movw	r30, r26
    1b8e:	0d c0       	rjmp	.+26     	; 0x1baa <__udivmodsi4_ep>

00001b90 <__udivmodsi4_loop>:
    1b90:	aa 1f       	adc	r26, r26
    1b92:	bb 1f       	adc	r27, r27
    1b94:	ee 1f       	adc	r30, r30
    1b96:	ff 1f       	adc	r31, r31
    1b98:	a2 17       	cp	r26, r18
    1b9a:	b3 07       	cpc	r27, r19
    1b9c:	e4 07       	cpc	r30, r20
    1b9e:	f5 07       	cpc	r31, r21
    1ba0:	20 f0       	brcs	.+8      	; 0x1baa <__udivmodsi4_ep>
    1ba2:	a2 1b       	sub	r26, r18
    1ba4:	b3 0b       	sbc	r27, r19
    1ba6:	e4 0b       	sbc	r30, r20
    1ba8:	f5 0b       	sbc	r31, r21

00001baa <__udivmodsi4_ep>:
    1baa:	66 1f       	adc	r22, r22
    1bac:	77 1f       	adc	r23, r23
    1bae:	88 1f       	adc	r24, r24
    1bb0:	99 1f       	adc	r25, r25
    1bb2:	1a 94       	dec	r1
    1bb4:	69 f7       	brne	.-38     	; 0x1b90 <__udivmodsi4_loop>
    1bb6:	60 95       	com	r22
    1bb8:	70 95       	com	r23
    1bba:	80 95       	com	r24
    1bbc:	90 95       	com	r25
    1bbe:	9b 01       	movw	r18, r22
    1bc0:	ac 01       	movw	r20, r24
    1bc2:	bd 01       	movw	r22, r26
    1bc4:	cf 01       	movw	r24, r30
    1bc6:	08 95       	ret

00001bc8 <__muluhisi3>:
    1bc8:	0e 94 ef 0d 	call	0x1bde	; 0x1bde <__umulhisi3>
    1bcc:	a5 9f       	mul	r26, r21
    1bce:	90 0d       	add	r25, r0
    1bd0:	b4 9f       	mul	r27, r20
    1bd2:	90 0d       	add	r25, r0
    1bd4:	a4 9f       	mul	r26, r20
    1bd6:	80 0d       	add	r24, r0
    1bd8:	91 1d       	adc	r25, r1
    1bda:	11 24       	eor	r1, r1
    1bdc:	08 95       	ret

00001bde <__umulhisi3>:
    1bde:	a2 9f       	mul	r26, r18
    1be0:	b0 01       	movw	r22, r0
    1be2:	b3 9f       	mul	r27, r19
    1be4:	c0 01       	movw	r24, r0
    1be6:	a3 9f       	mul	r26, r19
    1be8:	70 0d       	add	r23, r0
    1bea:	81 1d       	adc	r24, r1
    1bec:	11 24       	eor	r1, r1
    1bee:	91 1d       	adc	r25, r1
    1bf0:	b2 9f       	mul	r27, r18
    1bf2:	70 0d       	add	r23, r0
    1bf4:	81 1d       	adc	r24, r1
    1bf6:	11 24       	eor	r1, r1
    1bf8:	91 1d       	adc	r25, r1
    1bfa:	08 95       	ret

00001bfc <do_rand>:
    1bfc:	8f 92       	push	r8
    1bfe:	9f 92       	push	r9
    1c00:	af 92       	push	r10
    1c02:	bf 92       	push	r11
    1c04:	cf 92       	push	r12
    1c06:	df 92       	push	r13
    1c08:	ef 92       	push	r14
    1c0a:	ff 92       	push	r15
    1c0c:	cf 93       	push	r28
    1c0e:	df 93       	push	r29
    1c10:	ec 01       	movw	r28, r24
    1c12:	68 81       	ld	r22, Y
    1c14:	79 81       	ldd	r23, Y+1	; 0x01
    1c16:	8a 81       	ldd	r24, Y+2	; 0x02
    1c18:	9b 81       	ldd	r25, Y+3	; 0x03
    1c1a:	61 15       	cp	r22, r1
    1c1c:	71 05       	cpc	r23, r1
    1c1e:	81 05       	cpc	r24, r1
    1c20:	91 05       	cpc	r25, r1
    1c22:	21 f4       	brne	.+8      	; 0x1c2c <do_rand+0x30>
    1c24:	64 e2       	ldi	r22, 0x24	; 36
    1c26:	79 ed       	ldi	r23, 0xD9	; 217
    1c28:	8b e5       	ldi	r24, 0x5B	; 91
    1c2a:	97 e0       	ldi	r25, 0x07	; 7
    1c2c:	2d e1       	ldi	r18, 0x1D	; 29
    1c2e:	33 ef       	ldi	r19, 0xF3	; 243
    1c30:	41 e0       	ldi	r20, 0x01	; 1
    1c32:	50 e0       	ldi	r21, 0x00	; 0
    1c34:	0e 94 8c 11 	call	0x2318	; 0x2318 <__divmodsi4>
    1c38:	49 01       	movw	r8, r18
    1c3a:	5a 01       	movw	r10, r20
    1c3c:	9b 01       	movw	r18, r22
    1c3e:	ac 01       	movw	r20, r24
    1c40:	a7 ea       	ldi	r26, 0xA7	; 167
    1c42:	b1 e4       	ldi	r27, 0x41	; 65
    1c44:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <__muluhisi3>
    1c48:	6b 01       	movw	r12, r22
    1c4a:	7c 01       	movw	r14, r24
    1c4c:	ac ee       	ldi	r26, 0xEC	; 236
    1c4e:	b4 ef       	ldi	r27, 0xF4	; 244
    1c50:	a5 01       	movw	r20, r10
    1c52:	94 01       	movw	r18, r8
    1c54:	0e 94 ae 11 	call	0x235c	; 0x235c <__mulohisi3>
    1c58:	dc 01       	movw	r26, r24
    1c5a:	cb 01       	movw	r24, r22
    1c5c:	8c 0d       	add	r24, r12
    1c5e:	9d 1d       	adc	r25, r13
    1c60:	ae 1d       	adc	r26, r14
    1c62:	bf 1d       	adc	r27, r15
    1c64:	b7 ff       	sbrs	r27, 7
    1c66:	03 c0       	rjmp	.+6      	; 0x1c6e <do_rand+0x72>
    1c68:	01 97       	sbiw	r24, 0x01	; 1
    1c6a:	a1 09       	sbc	r26, r1
    1c6c:	b0 48       	sbci	r27, 0x80	; 128
    1c6e:	88 83       	st	Y, r24
    1c70:	99 83       	std	Y+1, r25	; 0x01
    1c72:	aa 83       	std	Y+2, r26	; 0x02
    1c74:	bb 83       	std	Y+3, r27	; 0x03
    1c76:	9f 77       	andi	r25, 0x7F	; 127
    1c78:	df 91       	pop	r29
    1c7a:	cf 91       	pop	r28
    1c7c:	ff 90       	pop	r15
    1c7e:	ef 90       	pop	r14
    1c80:	df 90       	pop	r13
    1c82:	cf 90       	pop	r12
    1c84:	bf 90       	pop	r11
    1c86:	af 90       	pop	r10
    1c88:	9f 90       	pop	r9
    1c8a:	8f 90       	pop	r8
    1c8c:	08 95       	ret

00001c8e <rand_r>:
    1c8e:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <do_rand>
    1c92:	08 95       	ret

00001c94 <rand>:
    1c94:	8e e0       	ldi	r24, 0x0E	; 14
    1c96:	91 e0       	ldi	r25, 0x01	; 1
    1c98:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <do_rand>
    1c9c:	08 95       	ret

00001c9e <srand>:
    1c9e:	a0 e0       	ldi	r26, 0x00	; 0
    1ca0:	b0 e0       	ldi	r27, 0x00	; 0
    1ca2:	80 93 0e 01 	sts	0x010E, r24
    1ca6:	90 93 0f 01 	sts	0x010F, r25
    1caa:	a0 93 10 01 	sts	0x0110, r26
    1cae:	b0 93 11 01 	sts	0x0111, r27
    1cb2:	08 95       	ret

00001cb4 <atoi>:
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	88 27       	eor	r24, r24
    1cb8:	99 27       	eor	r25, r25
    1cba:	e8 94       	clt
    1cbc:	21 91       	ld	r18, Z+
    1cbe:	20 32       	cpi	r18, 0x20	; 32
    1cc0:	e9 f3       	breq	.-6      	; 0x1cbc <atoi+0x8>
    1cc2:	29 30       	cpi	r18, 0x09	; 9
    1cc4:	10 f0       	brcs	.+4      	; 0x1cca <atoi+0x16>
    1cc6:	2e 30       	cpi	r18, 0x0E	; 14
    1cc8:	c8 f3       	brcs	.-14     	; 0x1cbc <atoi+0x8>
    1cca:	2b 32       	cpi	r18, 0x2B	; 43
    1ccc:	41 f0       	breq	.+16     	; 0x1cde <atoi+0x2a>
    1cce:	2d 32       	cpi	r18, 0x2D	; 45
    1cd0:	39 f4       	brne	.+14     	; 0x1ce0 <atoi+0x2c>
    1cd2:	68 94       	set
    1cd4:	04 c0       	rjmp	.+8      	; 0x1cde <atoi+0x2a>
    1cd6:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <__mulhi_const_10>
    1cda:	82 0f       	add	r24, r18
    1cdc:	91 1d       	adc	r25, r1
    1cde:	21 91       	ld	r18, Z+
    1ce0:	20 53       	subi	r18, 0x30	; 48
    1ce2:	2a 30       	cpi	r18, 0x0A	; 10
    1ce4:	c0 f3       	brcs	.-16     	; 0x1cd6 <atoi+0x22>
    1ce6:	1e f4       	brtc	.+6      	; 0x1cee <atoi+0x3a>
    1ce8:	90 95       	com	r25
    1cea:	81 95       	neg	r24
    1cec:	9f 4f       	sbci	r25, 0xFF	; 255
    1cee:	08 95       	ret

00001cf0 <memcmp>:
    1cf0:	fb 01       	movw	r30, r22
    1cf2:	dc 01       	movw	r26, r24
    1cf4:	04 c0       	rjmp	.+8      	; 0x1cfe <memcmp+0xe>
    1cf6:	8d 91       	ld	r24, X+
    1cf8:	01 90       	ld	r0, Z+
    1cfa:	80 19       	sub	r24, r0
    1cfc:	21 f4       	brne	.+8      	; 0x1d06 <memcmp+0x16>
    1cfe:	41 50       	subi	r20, 0x01	; 1
    1d00:	50 40       	sbci	r21, 0x00	; 0
    1d02:	c8 f7       	brcc	.-14     	; 0x1cf6 <memcmp+0x6>
    1d04:	88 1b       	sub	r24, r24
    1d06:	99 0b       	sbc	r25, r25
    1d08:	08 95       	ret

00001d0a <__mulhi_const_10>:
    1d0a:	7a e0       	ldi	r23, 0x0A	; 10
    1d0c:	97 9f       	mul	r25, r23
    1d0e:	90 2d       	mov	r25, r0
    1d10:	87 9f       	mul	r24, r23
    1d12:	80 2d       	mov	r24, r0
    1d14:	91 0d       	add	r25, r1
    1d16:	11 24       	eor	r1, r1
    1d18:	08 95       	ret

00001d1a <fgetc>:
    1d1a:	cf 93       	push	r28
    1d1c:	df 93       	push	r29
    1d1e:	ec 01       	movw	r28, r24
    1d20:	2b 81       	ldd	r18, Y+3	; 0x03
    1d22:	20 ff       	sbrs	r18, 0
    1d24:	33 c0       	rjmp	.+102    	; 0x1d8c <fgetc+0x72>
    1d26:	26 ff       	sbrs	r18, 6
    1d28:	0a c0       	rjmp	.+20     	; 0x1d3e <fgetc+0x24>
    1d2a:	2f 7b       	andi	r18, 0xBF	; 191
    1d2c:	2b 83       	std	Y+3, r18	; 0x03
    1d2e:	8e 81       	ldd	r24, Y+6	; 0x06
    1d30:	9f 81       	ldd	r25, Y+7	; 0x07
    1d32:	01 96       	adiw	r24, 0x01	; 1
    1d34:	9f 83       	std	Y+7, r25	; 0x07
    1d36:	8e 83       	std	Y+6, r24	; 0x06
    1d38:	8a 81       	ldd	r24, Y+2	; 0x02
    1d3a:	90 e0       	ldi	r25, 0x00	; 0
    1d3c:	29 c0       	rjmp	.+82     	; 0x1d90 <fgetc+0x76>
    1d3e:	22 ff       	sbrs	r18, 2
    1d40:	0f c0       	rjmp	.+30     	; 0x1d60 <fgetc+0x46>
    1d42:	e8 81       	ld	r30, Y
    1d44:	f9 81       	ldd	r31, Y+1	; 0x01
    1d46:	80 81       	ld	r24, Z
    1d48:	08 2e       	mov	r0, r24
    1d4a:	00 0c       	add	r0, r0
    1d4c:	99 0b       	sbc	r25, r25
    1d4e:	00 97       	sbiw	r24, 0x00	; 0
    1d50:	19 f4       	brne	.+6      	; 0x1d58 <fgetc+0x3e>
    1d52:	20 62       	ori	r18, 0x20	; 32
    1d54:	2b 83       	std	Y+3, r18	; 0x03
    1d56:	1a c0       	rjmp	.+52     	; 0x1d8c <fgetc+0x72>
    1d58:	31 96       	adiw	r30, 0x01	; 1
    1d5a:	f9 83       	std	Y+1, r31	; 0x01
    1d5c:	e8 83       	st	Y, r30
    1d5e:	0e c0       	rjmp	.+28     	; 0x1d7c <fgetc+0x62>
    1d60:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d62:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d64:	09 95       	icall
    1d66:	97 ff       	sbrs	r25, 7
    1d68:	09 c0       	rjmp	.+18     	; 0x1d7c <fgetc+0x62>
    1d6a:	2b 81       	ldd	r18, Y+3	; 0x03
    1d6c:	01 96       	adiw	r24, 0x01	; 1
    1d6e:	11 f0       	breq	.+4      	; 0x1d74 <fgetc+0x5a>
    1d70:	80 e2       	ldi	r24, 0x20	; 32
    1d72:	01 c0       	rjmp	.+2      	; 0x1d76 <fgetc+0x5c>
    1d74:	80 e1       	ldi	r24, 0x10	; 16
    1d76:	82 2b       	or	r24, r18
    1d78:	8b 83       	std	Y+3, r24	; 0x03
    1d7a:	08 c0       	rjmp	.+16     	; 0x1d8c <fgetc+0x72>
    1d7c:	2e 81       	ldd	r18, Y+6	; 0x06
    1d7e:	3f 81       	ldd	r19, Y+7	; 0x07
    1d80:	2f 5f       	subi	r18, 0xFF	; 255
    1d82:	3f 4f       	sbci	r19, 0xFF	; 255
    1d84:	3f 83       	std	Y+7, r19	; 0x07
    1d86:	2e 83       	std	Y+6, r18	; 0x06
    1d88:	99 27       	eor	r25, r25
    1d8a:	02 c0       	rjmp	.+4      	; 0x1d90 <fgetc+0x76>
    1d8c:	8f ef       	ldi	r24, 0xFF	; 255
    1d8e:	9f ef       	ldi	r25, 0xFF	; 255
    1d90:	df 91       	pop	r29
    1d92:	cf 91       	pop	r28
    1d94:	08 95       	ret

00001d96 <fputc>:
    1d96:	0f 93       	push	r16
    1d98:	1f 93       	push	r17
    1d9a:	cf 93       	push	r28
    1d9c:	df 93       	push	r29
    1d9e:	fb 01       	movw	r30, r22
    1da0:	23 81       	ldd	r18, Z+3	; 0x03
    1da2:	21 fd       	sbrc	r18, 1
    1da4:	03 c0       	rjmp	.+6      	; 0x1dac <fputc+0x16>
    1da6:	8f ef       	ldi	r24, 0xFF	; 255
    1da8:	9f ef       	ldi	r25, 0xFF	; 255
    1daa:	28 c0       	rjmp	.+80     	; 0x1dfc <fputc+0x66>
    1dac:	22 ff       	sbrs	r18, 2
    1dae:	16 c0       	rjmp	.+44     	; 0x1ddc <fputc+0x46>
    1db0:	46 81       	ldd	r20, Z+6	; 0x06
    1db2:	57 81       	ldd	r21, Z+7	; 0x07
    1db4:	24 81       	ldd	r18, Z+4	; 0x04
    1db6:	35 81       	ldd	r19, Z+5	; 0x05
    1db8:	42 17       	cp	r20, r18
    1dba:	53 07       	cpc	r21, r19
    1dbc:	44 f4       	brge	.+16     	; 0x1dce <fputc+0x38>
    1dbe:	a0 81       	ld	r26, Z
    1dc0:	b1 81       	ldd	r27, Z+1	; 0x01
    1dc2:	9d 01       	movw	r18, r26
    1dc4:	2f 5f       	subi	r18, 0xFF	; 255
    1dc6:	3f 4f       	sbci	r19, 0xFF	; 255
    1dc8:	31 83       	std	Z+1, r19	; 0x01
    1dca:	20 83       	st	Z, r18
    1dcc:	8c 93       	st	X, r24
    1dce:	26 81       	ldd	r18, Z+6	; 0x06
    1dd0:	37 81       	ldd	r19, Z+7	; 0x07
    1dd2:	2f 5f       	subi	r18, 0xFF	; 255
    1dd4:	3f 4f       	sbci	r19, 0xFF	; 255
    1dd6:	37 83       	std	Z+7, r19	; 0x07
    1dd8:	26 83       	std	Z+6, r18	; 0x06
    1dda:	10 c0       	rjmp	.+32     	; 0x1dfc <fputc+0x66>
    1ddc:	eb 01       	movw	r28, r22
    1dde:	09 2f       	mov	r16, r25
    1de0:	18 2f       	mov	r17, r24
    1de2:	00 84       	ldd	r0, Z+8	; 0x08
    1de4:	f1 85       	ldd	r31, Z+9	; 0x09
    1de6:	e0 2d       	mov	r30, r0
    1de8:	09 95       	icall
    1dea:	89 2b       	or	r24, r25
    1dec:	e1 f6       	brne	.-72     	; 0x1da6 <fputc+0x10>
    1dee:	8e 81       	ldd	r24, Y+6	; 0x06
    1df0:	9f 81       	ldd	r25, Y+7	; 0x07
    1df2:	01 96       	adiw	r24, 0x01	; 1
    1df4:	9f 83       	std	Y+7, r25	; 0x07
    1df6:	8e 83       	std	Y+6, r24	; 0x06
    1df8:	81 2f       	mov	r24, r17
    1dfa:	90 2f       	mov	r25, r16
    1dfc:	df 91       	pop	r29
    1dfe:	cf 91       	pop	r28
    1e00:	1f 91       	pop	r17
    1e02:	0f 91       	pop	r16
    1e04:	08 95       	ret

00001e06 <printf>:
    1e06:	a0 e0       	ldi	r26, 0x00	; 0
    1e08:	b0 e0       	ldi	r27, 0x00	; 0
    1e0a:	e9 e0       	ldi	r30, 0x09	; 9
    1e0c:	ff e0       	ldi	r31, 0x0F	; 15
    1e0e:	0c 94 c3 11 	jmp	0x2386	; 0x2386 <__prologue_saves__+0x20>
    1e12:	ae 01       	movw	r20, r28
    1e14:	4b 5f       	subi	r20, 0xFB	; 251
    1e16:	5f 4f       	sbci	r21, 0xFF	; 255
    1e18:	fa 01       	movw	r30, r20
    1e1a:	61 91       	ld	r22, Z+
    1e1c:	71 91       	ld	r23, Z+
    1e1e:	af 01       	movw	r20, r30
    1e20:	80 91 73 07 	lds	r24, 0x0773
    1e24:	90 91 74 07 	lds	r25, 0x0774
    1e28:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <vfprintf>
    1e2c:	e2 e0       	ldi	r30, 0x02	; 2
    1e2e:	0c 94 df 11 	jmp	0x23be	; 0x23be <__epilogue_restores__+0x20>

00001e32 <printf_P>:
    1e32:	a0 e0       	ldi	r26, 0x00	; 0
    1e34:	b0 e0       	ldi	r27, 0x00	; 0
    1e36:	ef e1       	ldi	r30, 0x1F	; 31
    1e38:	ff e0       	ldi	r31, 0x0F	; 15
    1e3a:	0c 94 c1 11 	jmp	0x2382	; 0x2382 <__prologue_saves__+0x1c>
    1e3e:	ae 01       	movw	r20, r28
    1e40:	49 5f       	subi	r20, 0xF9	; 249
    1e42:	5f 4f       	sbci	r21, 0xFF	; 255
    1e44:	da 01       	movw	r26, r20
    1e46:	6d 91       	ld	r22, X+
    1e48:	7d 91       	ld	r23, X+
    1e4a:	ad 01       	movw	r20, r26
    1e4c:	01 e7       	ldi	r16, 0x71	; 113
    1e4e:	17 e0       	ldi	r17, 0x07	; 7
    1e50:	f8 01       	movw	r30, r16
    1e52:	82 81       	ldd	r24, Z+2	; 0x02
    1e54:	93 81       	ldd	r25, Z+3	; 0x03
    1e56:	dc 01       	movw	r26, r24
    1e58:	13 96       	adiw	r26, 0x03	; 3
    1e5a:	2c 91       	ld	r18, X
    1e5c:	13 97       	sbiw	r26, 0x03	; 3
    1e5e:	28 60       	ori	r18, 0x08	; 8
    1e60:	13 96       	adiw	r26, 0x03	; 3
    1e62:	2c 93       	st	X, r18
    1e64:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <vfprintf>
    1e68:	d8 01       	movw	r26, r16
    1e6a:	12 96       	adiw	r26, 0x02	; 2
    1e6c:	ed 91       	ld	r30, X+
    1e6e:	fc 91       	ld	r31, X
    1e70:	13 97       	sbiw	r26, 0x03	; 3
    1e72:	23 81       	ldd	r18, Z+3	; 0x03
    1e74:	27 7f       	andi	r18, 0xF7	; 247
    1e76:	23 83       	std	Z+3, r18	; 0x03
    1e78:	e4 e0       	ldi	r30, 0x04	; 4
    1e7a:	0c 94 dd 11 	jmp	0x23ba	; 0x23ba <__epilogue_restores__+0x1c>

00001e7e <putchar>:
    1e7e:	60 91 73 07 	lds	r22, 0x0773
    1e82:	70 91 74 07 	lds	r23, 0x0774
    1e86:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    1e8a:	08 95       	ret

00001e8c <vfprintf>:
    1e8c:	ac e0       	ldi	r26, 0x0C	; 12
    1e8e:	b0 e0       	ldi	r27, 0x00	; 0
    1e90:	ec e4       	ldi	r30, 0x4C	; 76
    1e92:	ff e0       	ldi	r31, 0x0F	; 15
    1e94:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__prologue_saves__>
    1e98:	7c 01       	movw	r14, r24
    1e9a:	6b 01       	movw	r12, r22
    1e9c:	8a 01       	movw	r16, r20
    1e9e:	fc 01       	movw	r30, r24
    1ea0:	17 82       	std	Z+7, r1	; 0x07
    1ea2:	16 82       	std	Z+6, r1	; 0x06
    1ea4:	83 81       	ldd	r24, Z+3	; 0x03
    1ea6:	81 ff       	sbrs	r24, 1
    1ea8:	bd c1       	rjmp	.+890    	; 0x2224 <vfprintf+0x398>
    1eaa:	ce 01       	movw	r24, r28
    1eac:	01 96       	adiw	r24, 0x01	; 1
    1eae:	4c 01       	movw	r8, r24
    1eb0:	f7 01       	movw	r30, r14
    1eb2:	93 81       	ldd	r25, Z+3	; 0x03
    1eb4:	f6 01       	movw	r30, r12
    1eb6:	93 fd       	sbrc	r25, 3
    1eb8:	85 91       	lpm	r24, Z+
    1eba:	93 ff       	sbrs	r25, 3
    1ebc:	81 91       	ld	r24, Z+
    1ebe:	6f 01       	movw	r12, r30
    1ec0:	88 23       	and	r24, r24
    1ec2:	09 f4       	brne	.+2      	; 0x1ec6 <vfprintf+0x3a>
    1ec4:	ab c1       	rjmp	.+854    	; 0x221c <vfprintf+0x390>
    1ec6:	85 32       	cpi	r24, 0x25	; 37
    1ec8:	39 f4       	brne	.+14     	; 0x1ed8 <vfprintf+0x4c>
    1eca:	93 fd       	sbrc	r25, 3
    1ecc:	85 91       	lpm	r24, Z+
    1ece:	93 ff       	sbrs	r25, 3
    1ed0:	81 91       	ld	r24, Z+
    1ed2:	6f 01       	movw	r12, r30
    1ed4:	85 32       	cpi	r24, 0x25	; 37
    1ed6:	29 f4       	brne	.+10     	; 0x1ee2 <vfprintf+0x56>
    1ed8:	b7 01       	movw	r22, r14
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    1ee0:	e7 cf       	rjmp	.-50     	; 0x1eb0 <vfprintf+0x24>
    1ee2:	51 2c       	mov	r5, r1
    1ee4:	31 2c       	mov	r3, r1
    1ee6:	20 e0       	ldi	r18, 0x00	; 0
    1ee8:	20 32       	cpi	r18, 0x20	; 32
    1eea:	a0 f4       	brcc	.+40     	; 0x1f14 <vfprintf+0x88>
    1eec:	8b 32       	cpi	r24, 0x2B	; 43
    1eee:	69 f0       	breq	.+26     	; 0x1f0a <vfprintf+0x7e>
    1ef0:	30 f4       	brcc	.+12     	; 0x1efe <vfprintf+0x72>
    1ef2:	80 32       	cpi	r24, 0x20	; 32
    1ef4:	59 f0       	breq	.+22     	; 0x1f0c <vfprintf+0x80>
    1ef6:	83 32       	cpi	r24, 0x23	; 35
    1ef8:	69 f4       	brne	.+26     	; 0x1f14 <vfprintf+0x88>
    1efa:	20 61       	ori	r18, 0x10	; 16
    1efc:	2c c0       	rjmp	.+88     	; 0x1f56 <vfprintf+0xca>
    1efe:	8d 32       	cpi	r24, 0x2D	; 45
    1f00:	39 f0       	breq	.+14     	; 0x1f10 <vfprintf+0x84>
    1f02:	80 33       	cpi	r24, 0x30	; 48
    1f04:	39 f4       	brne	.+14     	; 0x1f14 <vfprintf+0x88>
    1f06:	21 60       	ori	r18, 0x01	; 1
    1f08:	26 c0       	rjmp	.+76     	; 0x1f56 <vfprintf+0xca>
    1f0a:	22 60       	ori	r18, 0x02	; 2
    1f0c:	24 60       	ori	r18, 0x04	; 4
    1f0e:	23 c0       	rjmp	.+70     	; 0x1f56 <vfprintf+0xca>
    1f10:	28 60       	ori	r18, 0x08	; 8
    1f12:	21 c0       	rjmp	.+66     	; 0x1f56 <vfprintf+0xca>
    1f14:	27 fd       	sbrc	r18, 7
    1f16:	27 c0       	rjmp	.+78     	; 0x1f66 <vfprintf+0xda>
    1f18:	30 ed       	ldi	r19, 0xD0	; 208
    1f1a:	38 0f       	add	r19, r24
    1f1c:	3a 30       	cpi	r19, 0x0A	; 10
    1f1e:	78 f4       	brcc	.+30     	; 0x1f3e <vfprintf+0xb2>
    1f20:	26 ff       	sbrs	r18, 6
    1f22:	06 c0       	rjmp	.+12     	; 0x1f30 <vfprintf+0xa4>
    1f24:	fa e0       	ldi	r31, 0x0A	; 10
    1f26:	5f 9e       	mul	r5, r31
    1f28:	30 0d       	add	r19, r0
    1f2a:	11 24       	eor	r1, r1
    1f2c:	53 2e       	mov	r5, r19
    1f2e:	13 c0       	rjmp	.+38     	; 0x1f56 <vfprintf+0xca>
    1f30:	8a e0       	ldi	r24, 0x0A	; 10
    1f32:	38 9e       	mul	r3, r24
    1f34:	30 0d       	add	r19, r0
    1f36:	11 24       	eor	r1, r1
    1f38:	33 2e       	mov	r3, r19
    1f3a:	20 62       	ori	r18, 0x20	; 32
    1f3c:	0c c0       	rjmp	.+24     	; 0x1f56 <vfprintf+0xca>
    1f3e:	8e 32       	cpi	r24, 0x2E	; 46
    1f40:	21 f4       	brne	.+8      	; 0x1f4a <vfprintf+0xbe>
    1f42:	26 fd       	sbrc	r18, 6
    1f44:	6b c1       	rjmp	.+726    	; 0x221c <vfprintf+0x390>
    1f46:	20 64       	ori	r18, 0x40	; 64
    1f48:	06 c0       	rjmp	.+12     	; 0x1f56 <vfprintf+0xca>
    1f4a:	8c 36       	cpi	r24, 0x6C	; 108
    1f4c:	11 f4       	brne	.+4      	; 0x1f52 <vfprintf+0xc6>
    1f4e:	20 68       	ori	r18, 0x80	; 128
    1f50:	02 c0       	rjmp	.+4      	; 0x1f56 <vfprintf+0xca>
    1f52:	88 36       	cpi	r24, 0x68	; 104
    1f54:	41 f4       	brne	.+16     	; 0x1f66 <vfprintf+0xda>
    1f56:	f6 01       	movw	r30, r12
    1f58:	93 fd       	sbrc	r25, 3
    1f5a:	85 91       	lpm	r24, Z+
    1f5c:	93 ff       	sbrs	r25, 3
    1f5e:	81 91       	ld	r24, Z+
    1f60:	6f 01       	movw	r12, r30
    1f62:	81 11       	cpse	r24, r1
    1f64:	c1 cf       	rjmp	.-126    	; 0x1ee8 <vfprintf+0x5c>
    1f66:	98 2f       	mov	r25, r24
    1f68:	9f 7d       	andi	r25, 0xDF	; 223
    1f6a:	95 54       	subi	r25, 0x45	; 69
    1f6c:	93 30       	cpi	r25, 0x03	; 3
    1f6e:	28 f4       	brcc	.+10     	; 0x1f7a <vfprintf+0xee>
    1f70:	0c 5f       	subi	r16, 0xFC	; 252
    1f72:	1f 4f       	sbci	r17, 0xFF	; 255
    1f74:	ff e3       	ldi	r31, 0x3F	; 63
    1f76:	f9 83       	std	Y+1, r31	; 0x01
    1f78:	0d c0       	rjmp	.+26     	; 0x1f94 <vfprintf+0x108>
    1f7a:	83 36       	cpi	r24, 0x63	; 99
    1f7c:	31 f0       	breq	.+12     	; 0x1f8a <vfprintf+0xfe>
    1f7e:	83 37       	cpi	r24, 0x73	; 115
    1f80:	71 f0       	breq	.+28     	; 0x1f9e <vfprintf+0x112>
    1f82:	83 35       	cpi	r24, 0x53	; 83
    1f84:	09 f0       	breq	.+2      	; 0x1f88 <vfprintf+0xfc>
    1f86:	5b c0       	rjmp	.+182    	; 0x203e <vfprintf+0x1b2>
    1f88:	22 c0       	rjmp	.+68     	; 0x1fce <vfprintf+0x142>
    1f8a:	f8 01       	movw	r30, r16
    1f8c:	80 81       	ld	r24, Z
    1f8e:	89 83       	std	Y+1, r24	; 0x01
    1f90:	0e 5f       	subi	r16, 0xFE	; 254
    1f92:	1f 4f       	sbci	r17, 0xFF	; 255
    1f94:	44 24       	eor	r4, r4
    1f96:	43 94       	inc	r4
    1f98:	51 2c       	mov	r5, r1
    1f9a:	54 01       	movw	r10, r8
    1f9c:	15 c0       	rjmp	.+42     	; 0x1fc8 <vfprintf+0x13c>
    1f9e:	38 01       	movw	r6, r16
    1fa0:	f2 e0       	ldi	r31, 0x02	; 2
    1fa2:	6f 0e       	add	r6, r31
    1fa4:	71 1c       	adc	r7, r1
    1fa6:	f8 01       	movw	r30, r16
    1fa8:	a0 80       	ld	r10, Z
    1faa:	b1 80       	ldd	r11, Z+1	; 0x01
    1fac:	26 ff       	sbrs	r18, 6
    1fae:	03 c0       	rjmp	.+6      	; 0x1fb6 <vfprintf+0x12a>
    1fb0:	65 2d       	mov	r22, r5
    1fb2:	70 e0       	ldi	r23, 0x00	; 0
    1fb4:	02 c0       	rjmp	.+4      	; 0x1fba <vfprintf+0x12e>
    1fb6:	6f ef       	ldi	r22, 0xFF	; 255
    1fb8:	7f ef       	ldi	r23, 0xFF	; 255
    1fba:	c5 01       	movw	r24, r10
    1fbc:	2c 87       	std	Y+12, r18	; 0x0c
    1fbe:	0e 94 23 11 	call	0x2246	; 0x2246 <strnlen>
    1fc2:	2c 01       	movw	r4, r24
    1fc4:	83 01       	movw	r16, r6
    1fc6:	2c 85       	ldd	r18, Y+12	; 0x0c
    1fc8:	2f 77       	andi	r18, 0x7F	; 127
    1fca:	22 2e       	mov	r2, r18
    1fcc:	17 c0       	rjmp	.+46     	; 0x1ffc <vfprintf+0x170>
    1fce:	38 01       	movw	r6, r16
    1fd0:	f2 e0       	ldi	r31, 0x02	; 2
    1fd2:	6f 0e       	add	r6, r31
    1fd4:	71 1c       	adc	r7, r1
    1fd6:	f8 01       	movw	r30, r16
    1fd8:	a0 80       	ld	r10, Z
    1fda:	b1 80       	ldd	r11, Z+1	; 0x01
    1fdc:	26 ff       	sbrs	r18, 6
    1fde:	03 c0       	rjmp	.+6      	; 0x1fe6 <vfprintf+0x15a>
    1fe0:	65 2d       	mov	r22, r5
    1fe2:	70 e0       	ldi	r23, 0x00	; 0
    1fe4:	02 c0       	rjmp	.+4      	; 0x1fea <vfprintf+0x15e>
    1fe6:	6f ef       	ldi	r22, 0xFF	; 255
    1fe8:	7f ef       	ldi	r23, 0xFF	; 255
    1fea:	c5 01       	movw	r24, r10
    1fec:	2c 87       	std	Y+12, r18	; 0x0c
    1fee:	0e 94 18 11 	call	0x2230	; 0x2230 <strnlen_P>
    1ff2:	2c 01       	movw	r4, r24
    1ff4:	2c 85       	ldd	r18, Y+12	; 0x0c
    1ff6:	20 68       	ori	r18, 0x80	; 128
    1ff8:	22 2e       	mov	r2, r18
    1ffa:	83 01       	movw	r16, r6
    1ffc:	23 fc       	sbrc	r2, 3
    1ffe:	1b c0       	rjmp	.+54     	; 0x2036 <vfprintf+0x1aa>
    2000:	83 2d       	mov	r24, r3
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	48 16       	cp	r4, r24
    2006:	59 06       	cpc	r5, r25
    2008:	b0 f4       	brcc	.+44     	; 0x2036 <vfprintf+0x1aa>
    200a:	b7 01       	movw	r22, r14
    200c:	80 e2       	ldi	r24, 0x20	; 32
    200e:	90 e0       	ldi	r25, 0x00	; 0
    2010:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    2014:	3a 94       	dec	r3
    2016:	f4 cf       	rjmp	.-24     	; 0x2000 <vfprintf+0x174>
    2018:	f5 01       	movw	r30, r10
    201a:	27 fc       	sbrc	r2, 7
    201c:	85 91       	lpm	r24, Z+
    201e:	27 fe       	sbrs	r2, 7
    2020:	81 91       	ld	r24, Z+
    2022:	5f 01       	movw	r10, r30
    2024:	b7 01       	movw	r22, r14
    2026:	90 e0       	ldi	r25, 0x00	; 0
    2028:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    202c:	31 10       	cpse	r3, r1
    202e:	3a 94       	dec	r3
    2030:	f1 e0       	ldi	r31, 0x01	; 1
    2032:	4f 1a       	sub	r4, r31
    2034:	51 08       	sbc	r5, r1
    2036:	41 14       	cp	r4, r1
    2038:	51 04       	cpc	r5, r1
    203a:	71 f7       	brne	.-36     	; 0x2018 <vfprintf+0x18c>
    203c:	e5 c0       	rjmp	.+458    	; 0x2208 <vfprintf+0x37c>
    203e:	84 36       	cpi	r24, 0x64	; 100
    2040:	11 f0       	breq	.+4      	; 0x2046 <vfprintf+0x1ba>
    2042:	89 36       	cpi	r24, 0x69	; 105
    2044:	39 f5       	brne	.+78     	; 0x2094 <vfprintf+0x208>
    2046:	f8 01       	movw	r30, r16
    2048:	27 ff       	sbrs	r18, 7
    204a:	07 c0       	rjmp	.+14     	; 0x205a <vfprintf+0x1ce>
    204c:	60 81       	ld	r22, Z
    204e:	71 81       	ldd	r23, Z+1	; 0x01
    2050:	82 81       	ldd	r24, Z+2	; 0x02
    2052:	93 81       	ldd	r25, Z+3	; 0x03
    2054:	0c 5f       	subi	r16, 0xFC	; 252
    2056:	1f 4f       	sbci	r17, 0xFF	; 255
    2058:	08 c0       	rjmp	.+16     	; 0x206a <vfprintf+0x1de>
    205a:	60 81       	ld	r22, Z
    205c:	71 81       	ldd	r23, Z+1	; 0x01
    205e:	07 2e       	mov	r0, r23
    2060:	00 0c       	add	r0, r0
    2062:	88 0b       	sbc	r24, r24
    2064:	99 0b       	sbc	r25, r25
    2066:	0e 5f       	subi	r16, 0xFE	; 254
    2068:	1f 4f       	sbci	r17, 0xFF	; 255
    206a:	2f 76       	andi	r18, 0x6F	; 111
    206c:	72 2e       	mov	r7, r18
    206e:	97 ff       	sbrs	r25, 7
    2070:	09 c0       	rjmp	.+18     	; 0x2084 <vfprintf+0x1f8>
    2072:	90 95       	com	r25
    2074:	80 95       	com	r24
    2076:	70 95       	com	r23
    2078:	61 95       	neg	r22
    207a:	7f 4f       	sbci	r23, 0xFF	; 255
    207c:	8f 4f       	sbci	r24, 0xFF	; 255
    207e:	9f 4f       	sbci	r25, 0xFF	; 255
    2080:	20 68       	ori	r18, 0x80	; 128
    2082:	72 2e       	mov	r7, r18
    2084:	2a e0       	ldi	r18, 0x0A	; 10
    2086:	30 e0       	ldi	r19, 0x00	; 0
    2088:	a4 01       	movw	r20, r8
    208a:	0e 94 2e 11 	call	0x225c	; 0x225c <__ultoa_invert>
    208e:	a8 2e       	mov	r10, r24
    2090:	a8 18       	sub	r10, r8
    2092:	44 c0       	rjmp	.+136    	; 0x211c <vfprintf+0x290>
    2094:	85 37       	cpi	r24, 0x75	; 117
    2096:	29 f4       	brne	.+10     	; 0x20a2 <vfprintf+0x216>
    2098:	2f 7e       	andi	r18, 0xEF	; 239
    209a:	b2 2e       	mov	r11, r18
    209c:	2a e0       	ldi	r18, 0x0A	; 10
    209e:	30 e0       	ldi	r19, 0x00	; 0
    20a0:	25 c0       	rjmp	.+74     	; 0x20ec <vfprintf+0x260>
    20a2:	f2 2f       	mov	r31, r18
    20a4:	f9 7f       	andi	r31, 0xF9	; 249
    20a6:	bf 2e       	mov	r11, r31
    20a8:	8f 36       	cpi	r24, 0x6F	; 111
    20aa:	c1 f0       	breq	.+48     	; 0x20dc <vfprintf+0x250>
    20ac:	18 f4       	brcc	.+6      	; 0x20b4 <vfprintf+0x228>
    20ae:	88 35       	cpi	r24, 0x58	; 88
    20b0:	79 f0       	breq	.+30     	; 0x20d0 <vfprintf+0x244>
    20b2:	b4 c0       	rjmp	.+360    	; 0x221c <vfprintf+0x390>
    20b4:	80 37       	cpi	r24, 0x70	; 112
    20b6:	19 f0       	breq	.+6      	; 0x20be <vfprintf+0x232>
    20b8:	88 37       	cpi	r24, 0x78	; 120
    20ba:	21 f0       	breq	.+8      	; 0x20c4 <vfprintf+0x238>
    20bc:	af c0       	rjmp	.+350    	; 0x221c <vfprintf+0x390>
    20be:	2f 2f       	mov	r18, r31
    20c0:	20 61       	ori	r18, 0x10	; 16
    20c2:	b2 2e       	mov	r11, r18
    20c4:	b4 fe       	sbrs	r11, 4
    20c6:	0d c0       	rjmp	.+26     	; 0x20e2 <vfprintf+0x256>
    20c8:	8b 2d       	mov	r24, r11
    20ca:	84 60       	ori	r24, 0x04	; 4
    20cc:	b8 2e       	mov	r11, r24
    20ce:	09 c0       	rjmp	.+18     	; 0x20e2 <vfprintf+0x256>
    20d0:	24 ff       	sbrs	r18, 4
    20d2:	0a c0       	rjmp	.+20     	; 0x20e8 <vfprintf+0x25c>
    20d4:	9f 2f       	mov	r25, r31
    20d6:	96 60       	ori	r25, 0x06	; 6
    20d8:	b9 2e       	mov	r11, r25
    20da:	06 c0       	rjmp	.+12     	; 0x20e8 <vfprintf+0x25c>
    20dc:	28 e0       	ldi	r18, 0x08	; 8
    20de:	30 e0       	ldi	r19, 0x00	; 0
    20e0:	05 c0       	rjmp	.+10     	; 0x20ec <vfprintf+0x260>
    20e2:	20 e1       	ldi	r18, 0x10	; 16
    20e4:	30 e0       	ldi	r19, 0x00	; 0
    20e6:	02 c0       	rjmp	.+4      	; 0x20ec <vfprintf+0x260>
    20e8:	20 e1       	ldi	r18, 0x10	; 16
    20ea:	32 e0       	ldi	r19, 0x02	; 2
    20ec:	f8 01       	movw	r30, r16
    20ee:	b7 fe       	sbrs	r11, 7
    20f0:	07 c0       	rjmp	.+14     	; 0x2100 <vfprintf+0x274>
    20f2:	60 81       	ld	r22, Z
    20f4:	71 81       	ldd	r23, Z+1	; 0x01
    20f6:	82 81       	ldd	r24, Z+2	; 0x02
    20f8:	93 81       	ldd	r25, Z+3	; 0x03
    20fa:	0c 5f       	subi	r16, 0xFC	; 252
    20fc:	1f 4f       	sbci	r17, 0xFF	; 255
    20fe:	06 c0       	rjmp	.+12     	; 0x210c <vfprintf+0x280>
    2100:	60 81       	ld	r22, Z
    2102:	71 81       	ldd	r23, Z+1	; 0x01
    2104:	80 e0       	ldi	r24, 0x00	; 0
    2106:	90 e0       	ldi	r25, 0x00	; 0
    2108:	0e 5f       	subi	r16, 0xFE	; 254
    210a:	1f 4f       	sbci	r17, 0xFF	; 255
    210c:	a4 01       	movw	r20, r8
    210e:	0e 94 2e 11 	call	0x225c	; 0x225c <__ultoa_invert>
    2112:	a8 2e       	mov	r10, r24
    2114:	a8 18       	sub	r10, r8
    2116:	fb 2d       	mov	r31, r11
    2118:	ff 77       	andi	r31, 0x7F	; 127
    211a:	7f 2e       	mov	r7, r31
    211c:	76 fe       	sbrs	r7, 6
    211e:	0b c0       	rjmp	.+22     	; 0x2136 <vfprintf+0x2aa>
    2120:	37 2d       	mov	r19, r7
    2122:	3e 7f       	andi	r19, 0xFE	; 254
    2124:	a5 14       	cp	r10, r5
    2126:	50 f4       	brcc	.+20     	; 0x213c <vfprintf+0x2b0>
    2128:	74 fe       	sbrs	r7, 4
    212a:	0a c0       	rjmp	.+20     	; 0x2140 <vfprintf+0x2b4>
    212c:	72 fc       	sbrc	r7, 2
    212e:	08 c0       	rjmp	.+16     	; 0x2140 <vfprintf+0x2b4>
    2130:	37 2d       	mov	r19, r7
    2132:	3e 7e       	andi	r19, 0xEE	; 238
    2134:	05 c0       	rjmp	.+10     	; 0x2140 <vfprintf+0x2b4>
    2136:	ba 2c       	mov	r11, r10
    2138:	37 2d       	mov	r19, r7
    213a:	03 c0       	rjmp	.+6      	; 0x2142 <vfprintf+0x2b6>
    213c:	ba 2c       	mov	r11, r10
    213e:	01 c0       	rjmp	.+2      	; 0x2142 <vfprintf+0x2b6>
    2140:	b5 2c       	mov	r11, r5
    2142:	34 ff       	sbrs	r19, 4
    2144:	0d c0       	rjmp	.+26     	; 0x2160 <vfprintf+0x2d4>
    2146:	fe 01       	movw	r30, r28
    2148:	ea 0d       	add	r30, r10
    214a:	f1 1d       	adc	r31, r1
    214c:	80 81       	ld	r24, Z
    214e:	80 33       	cpi	r24, 0x30	; 48
    2150:	11 f4       	brne	.+4      	; 0x2156 <vfprintf+0x2ca>
    2152:	39 7e       	andi	r19, 0xE9	; 233
    2154:	09 c0       	rjmp	.+18     	; 0x2168 <vfprintf+0x2dc>
    2156:	32 ff       	sbrs	r19, 2
    2158:	06 c0       	rjmp	.+12     	; 0x2166 <vfprintf+0x2da>
    215a:	b3 94       	inc	r11
    215c:	b3 94       	inc	r11
    215e:	04 c0       	rjmp	.+8      	; 0x2168 <vfprintf+0x2dc>
    2160:	83 2f       	mov	r24, r19
    2162:	86 78       	andi	r24, 0x86	; 134
    2164:	09 f0       	breq	.+2      	; 0x2168 <vfprintf+0x2dc>
    2166:	b3 94       	inc	r11
    2168:	33 fd       	sbrc	r19, 3
    216a:	13 c0       	rjmp	.+38     	; 0x2192 <vfprintf+0x306>
    216c:	30 ff       	sbrs	r19, 0
    216e:	06 c0       	rjmp	.+12     	; 0x217c <vfprintf+0x2f0>
    2170:	5a 2c       	mov	r5, r10
    2172:	b3 14       	cp	r11, r3
    2174:	18 f4       	brcc	.+6      	; 0x217c <vfprintf+0x2f0>
    2176:	53 0c       	add	r5, r3
    2178:	5b 18       	sub	r5, r11
    217a:	b3 2c       	mov	r11, r3
    217c:	b3 14       	cp	r11, r3
    217e:	68 f4       	brcc	.+26     	; 0x219a <vfprintf+0x30e>
    2180:	b7 01       	movw	r22, r14
    2182:	80 e2       	ldi	r24, 0x20	; 32
    2184:	90 e0       	ldi	r25, 0x00	; 0
    2186:	3c 87       	std	Y+12, r19	; 0x0c
    2188:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    218c:	b3 94       	inc	r11
    218e:	3c 85       	ldd	r19, Y+12	; 0x0c
    2190:	f5 cf       	rjmp	.-22     	; 0x217c <vfprintf+0x2f0>
    2192:	b3 14       	cp	r11, r3
    2194:	10 f4       	brcc	.+4      	; 0x219a <vfprintf+0x30e>
    2196:	3b 18       	sub	r3, r11
    2198:	01 c0       	rjmp	.+2      	; 0x219c <vfprintf+0x310>
    219a:	31 2c       	mov	r3, r1
    219c:	34 ff       	sbrs	r19, 4
    219e:	12 c0       	rjmp	.+36     	; 0x21c4 <vfprintf+0x338>
    21a0:	b7 01       	movw	r22, r14
    21a2:	80 e3       	ldi	r24, 0x30	; 48
    21a4:	90 e0       	ldi	r25, 0x00	; 0
    21a6:	3c 87       	std	Y+12, r19	; 0x0c
    21a8:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    21ac:	3c 85       	ldd	r19, Y+12	; 0x0c
    21ae:	32 ff       	sbrs	r19, 2
    21b0:	17 c0       	rjmp	.+46     	; 0x21e0 <vfprintf+0x354>
    21b2:	31 fd       	sbrc	r19, 1
    21b4:	03 c0       	rjmp	.+6      	; 0x21bc <vfprintf+0x330>
    21b6:	88 e7       	ldi	r24, 0x78	; 120
    21b8:	90 e0       	ldi	r25, 0x00	; 0
    21ba:	02 c0       	rjmp	.+4      	; 0x21c0 <vfprintf+0x334>
    21bc:	88 e5       	ldi	r24, 0x58	; 88
    21be:	90 e0       	ldi	r25, 0x00	; 0
    21c0:	b7 01       	movw	r22, r14
    21c2:	0c c0       	rjmp	.+24     	; 0x21dc <vfprintf+0x350>
    21c4:	83 2f       	mov	r24, r19
    21c6:	86 78       	andi	r24, 0x86	; 134
    21c8:	59 f0       	breq	.+22     	; 0x21e0 <vfprintf+0x354>
    21ca:	31 ff       	sbrs	r19, 1
    21cc:	02 c0       	rjmp	.+4      	; 0x21d2 <vfprintf+0x346>
    21ce:	8b e2       	ldi	r24, 0x2B	; 43
    21d0:	01 c0       	rjmp	.+2      	; 0x21d4 <vfprintf+0x348>
    21d2:	80 e2       	ldi	r24, 0x20	; 32
    21d4:	37 fd       	sbrc	r19, 7
    21d6:	8d e2       	ldi	r24, 0x2D	; 45
    21d8:	b7 01       	movw	r22, r14
    21da:	90 e0       	ldi	r25, 0x00	; 0
    21dc:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    21e0:	a5 14       	cp	r10, r5
    21e2:	38 f4       	brcc	.+14     	; 0x21f2 <vfprintf+0x366>
    21e4:	b7 01       	movw	r22, r14
    21e6:	80 e3       	ldi	r24, 0x30	; 48
    21e8:	90 e0       	ldi	r25, 0x00	; 0
    21ea:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    21ee:	5a 94       	dec	r5
    21f0:	f7 cf       	rjmp	.-18     	; 0x21e0 <vfprintf+0x354>
    21f2:	aa 94       	dec	r10
    21f4:	f4 01       	movw	r30, r8
    21f6:	ea 0d       	add	r30, r10
    21f8:	f1 1d       	adc	r31, r1
    21fa:	80 81       	ld	r24, Z
    21fc:	b7 01       	movw	r22, r14
    21fe:	90 e0       	ldi	r25, 0x00	; 0
    2200:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    2204:	a1 10       	cpse	r10, r1
    2206:	f5 cf       	rjmp	.-22     	; 0x21f2 <vfprintf+0x366>
    2208:	33 20       	and	r3, r3
    220a:	09 f4       	brne	.+2      	; 0x220e <vfprintf+0x382>
    220c:	51 ce       	rjmp	.-862    	; 0x1eb0 <vfprintf+0x24>
    220e:	b7 01       	movw	r22, r14
    2210:	80 e2       	ldi	r24, 0x20	; 32
    2212:	90 e0       	ldi	r25, 0x00	; 0
    2214:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <fputc>
    2218:	3a 94       	dec	r3
    221a:	f6 cf       	rjmp	.-20     	; 0x2208 <vfprintf+0x37c>
    221c:	f7 01       	movw	r30, r14
    221e:	86 81       	ldd	r24, Z+6	; 0x06
    2220:	97 81       	ldd	r25, Z+7	; 0x07
    2222:	02 c0       	rjmp	.+4      	; 0x2228 <vfprintf+0x39c>
    2224:	8f ef       	ldi	r24, 0xFF	; 255
    2226:	9f ef       	ldi	r25, 0xFF	; 255
    2228:	2c 96       	adiw	r28, 0x0c	; 12
    222a:	e2 e1       	ldi	r30, 0x12	; 18
    222c:	0c 94 cf 11 	jmp	0x239e	; 0x239e <__epilogue_restores__>

00002230 <strnlen_P>:
    2230:	fc 01       	movw	r30, r24
    2232:	05 90       	lpm	r0, Z+
    2234:	61 50       	subi	r22, 0x01	; 1
    2236:	70 40       	sbci	r23, 0x00	; 0
    2238:	01 10       	cpse	r0, r1
    223a:	d8 f7       	brcc	.-10     	; 0x2232 <strnlen_P+0x2>
    223c:	80 95       	com	r24
    223e:	90 95       	com	r25
    2240:	8e 0f       	add	r24, r30
    2242:	9f 1f       	adc	r25, r31
    2244:	08 95       	ret

00002246 <strnlen>:
    2246:	fc 01       	movw	r30, r24
    2248:	61 50       	subi	r22, 0x01	; 1
    224a:	70 40       	sbci	r23, 0x00	; 0
    224c:	01 90       	ld	r0, Z+
    224e:	01 10       	cpse	r0, r1
    2250:	d8 f7       	brcc	.-10     	; 0x2248 <strnlen+0x2>
    2252:	80 95       	com	r24
    2254:	90 95       	com	r25
    2256:	8e 0f       	add	r24, r30
    2258:	9f 1f       	adc	r25, r31
    225a:	08 95       	ret

0000225c <__ultoa_invert>:
    225c:	fa 01       	movw	r30, r20
    225e:	aa 27       	eor	r26, r26
    2260:	28 30       	cpi	r18, 0x08	; 8
    2262:	51 f1       	breq	.+84     	; 0x22b8 <__ultoa_invert+0x5c>
    2264:	20 31       	cpi	r18, 0x10	; 16
    2266:	81 f1       	breq	.+96     	; 0x22c8 <__ultoa_invert+0x6c>
    2268:	e8 94       	clt
    226a:	6f 93       	push	r22
    226c:	6e 7f       	andi	r22, 0xFE	; 254
    226e:	6e 5f       	subi	r22, 0xFE	; 254
    2270:	7f 4f       	sbci	r23, 0xFF	; 255
    2272:	8f 4f       	sbci	r24, 0xFF	; 255
    2274:	9f 4f       	sbci	r25, 0xFF	; 255
    2276:	af 4f       	sbci	r26, 0xFF	; 255
    2278:	b1 e0       	ldi	r27, 0x01	; 1
    227a:	3e d0       	rcall	.+124    	; 0x22f8 <__ultoa_invert+0x9c>
    227c:	b4 e0       	ldi	r27, 0x04	; 4
    227e:	3c d0       	rcall	.+120    	; 0x22f8 <__ultoa_invert+0x9c>
    2280:	67 0f       	add	r22, r23
    2282:	78 1f       	adc	r23, r24
    2284:	89 1f       	adc	r24, r25
    2286:	9a 1f       	adc	r25, r26
    2288:	a1 1d       	adc	r26, r1
    228a:	68 0f       	add	r22, r24
    228c:	79 1f       	adc	r23, r25
    228e:	8a 1f       	adc	r24, r26
    2290:	91 1d       	adc	r25, r1
    2292:	a1 1d       	adc	r26, r1
    2294:	6a 0f       	add	r22, r26
    2296:	71 1d       	adc	r23, r1
    2298:	81 1d       	adc	r24, r1
    229a:	91 1d       	adc	r25, r1
    229c:	a1 1d       	adc	r26, r1
    229e:	20 d0       	rcall	.+64     	; 0x22e0 <__ultoa_invert+0x84>
    22a0:	09 f4       	brne	.+2      	; 0x22a4 <__ultoa_invert+0x48>
    22a2:	68 94       	set
    22a4:	3f 91       	pop	r19
    22a6:	2a e0       	ldi	r18, 0x0A	; 10
    22a8:	26 9f       	mul	r18, r22
    22aa:	11 24       	eor	r1, r1
    22ac:	30 19       	sub	r19, r0
    22ae:	30 5d       	subi	r19, 0xD0	; 208
    22b0:	31 93       	st	Z+, r19
    22b2:	de f6       	brtc	.-74     	; 0x226a <__ultoa_invert+0xe>
    22b4:	cf 01       	movw	r24, r30
    22b6:	08 95       	ret
    22b8:	46 2f       	mov	r20, r22
    22ba:	47 70       	andi	r20, 0x07	; 7
    22bc:	40 5d       	subi	r20, 0xD0	; 208
    22be:	41 93       	st	Z+, r20
    22c0:	b3 e0       	ldi	r27, 0x03	; 3
    22c2:	0f d0       	rcall	.+30     	; 0x22e2 <__ultoa_invert+0x86>
    22c4:	c9 f7       	brne	.-14     	; 0x22b8 <__ultoa_invert+0x5c>
    22c6:	f6 cf       	rjmp	.-20     	; 0x22b4 <__ultoa_invert+0x58>
    22c8:	46 2f       	mov	r20, r22
    22ca:	4f 70       	andi	r20, 0x0F	; 15
    22cc:	40 5d       	subi	r20, 0xD0	; 208
    22ce:	4a 33       	cpi	r20, 0x3A	; 58
    22d0:	18 f0       	brcs	.+6      	; 0x22d8 <__ultoa_invert+0x7c>
    22d2:	49 5d       	subi	r20, 0xD9	; 217
    22d4:	31 fd       	sbrc	r19, 1
    22d6:	40 52       	subi	r20, 0x20	; 32
    22d8:	41 93       	st	Z+, r20
    22da:	02 d0       	rcall	.+4      	; 0x22e0 <__ultoa_invert+0x84>
    22dc:	a9 f7       	brne	.-22     	; 0x22c8 <__ultoa_invert+0x6c>
    22de:	ea cf       	rjmp	.-44     	; 0x22b4 <__ultoa_invert+0x58>
    22e0:	b4 e0       	ldi	r27, 0x04	; 4
    22e2:	a6 95       	lsr	r26
    22e4:	97 95       	ror	r25
    22e6:	87 95       	ror	r24
    22e8:	77 95       	ror	r23
    22ea:	67 95       	ror	r22
    22ec:	ba 95       	dec	r27
    22ee:	c9 f7       	brne	.-14     	; 0x22e2 <__ultoa_invert+0x86>
    22f0:	00 97       	sbiw	r24, 0x00	; 0
    22f2:	61 05       	cpc	r22, r1
    22f4:	71 05       	cpc	r23, r1
    22f6:	08 95       	ret
    22f8:	9b 01       	movw	r18, r22
    22fa:	ac 01       	movw	r20, r24
    22fc:	0a 2e       	mov	r0, r26
    22fe:	06 94       	lsr	r0
    2300:	57 95       	ror	r21
    2302:	47 95       	ror	r20
    2304:	37 95       	ror	r19
    2306:	27 95       	ror	r18
    2308:	ba 95       	dec	r27
    230a:	c9 f7       	brne	.-14     	; 0x22fe <__ultoa_invert+0xa2>
    230c:	62 0f       	add	r22, r18
    230e:	73 1f       	adc	r23, r19
    2310:	84 1f       	adc	r24, r20
    2312:	95 1f       	adc	r25, r21
    2314:	a0 1d       	adc	r26, r0
    2316:	08 95       	ret

00002318 <__divmodsi4>:
    2318:	05 2e       	mov	r0, r21
    231a:	97 fb       	bst	r25, 7
    231c:	1e f4       	brtc	.+6      	; 0x2324 <__divmodsi4+0xc>
    231e:	00 94       	com	r0
    2320:	0e 94 a3 11 	call	0x2346	; 0x2346 <__negsi2>
    2324:	57 fd       	sbrc	r21, 7
    2326:	07 d0       	rcall	.+14     	; 0x2336 <__divmodsi4_neg2>
    2328:	0e 94 c2 0d 	call	0x1b84	; 0x1b84 <__udivmodsi4>
    232c:	07 fc       	sbrc	r0, 7
    232e:	03 d0       	rcall	.+6      	; 0x2336 <__divmodsi4_neg2>
    2330:	4e f4       	brtc	.+18     	; 0x2344 <__divmodsi4_exit>
    2332:	0c 94 a3 11 	jmp	0x2346	; 0x2346 <__negsi2>

00002336 <__divmodsi4_neg2>:
    2336:	50 95       	com	r21
    2338:	40 95       	com	r20
    233a:	30 95       	com	r19
    233c:	21 95       	neg	r18
    233e:	3f 4f       	sbci	r19, 0xFF	; 255
    2340:	4f 4f       	sbci	r20, 0xFF	; 255
    2342:	5f 4f       	sbci	r21, 0xFF	; 255

00002344 <__divmodsi4_exit>:
    2344:	08 95       	ret

00002346 <__negsi2>:
    2346:	90 95       	com	r25
    2348:	80 95       	com	r24
    234a:	70 95       	com	r23
    234c:	61 95       	neg	r22
    234e:	7f 4f       	sbci	r23, 0xFF	; 255
    2350:	8f 4f       	sbci	r24, 0xFF	; 255
    2352:	9f 4f       	sbci	r25, 0xFF	; 255
    2354:	08 95       	ret

00002356 <__mulshisi3>:
    2356:	b7 ff       	sbrs	r27, 7
    2358:	0c 94 e4 0d 	jmp	0x1bc8	; 0x1bc8 <__muluhisi3>

0000235c <__mulohisi3>:
    235c:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <__muluhisi3>
    2360:	82 1b       	sub	r24, r18
    2362:	93 0b       	sbc	r25, r19
    2364:	08 95       	ret

00002366 <__prologue_saves__>:
    2366:	2f 92       	push	r2
    2368:	3f 92       	push	r3
    236a:	4f 92       	push	r4
    236c:	5f 92       	push	r5
    236e:	6f 92       	push	r6
    2370:	7f 92       	push	r7
    2372:	8f 92       	push	r8
    2374:	9f 92       	push	r9
    2376:	af 92       	push	r10
    2378:	bf 92       	push	r11
    237a:	cf 92       	push	r12
    237c:	df 92       	push	r13
    237e:	ef 92       	push	r14
    2380:	ff 92       	push	r15
    2382:	0f 93       	push	r16
    2384:	1f 93       	push	r17
    2386:	cf 93       	push	r28
    2388:	df 93       	push	r29
    238a:	cd b7       	in	r28, 0x3d	; 61
    238c:	de b7       	in	r29, 0x3e	; 62
    238e:	ca 1b       	sub	r28, r26
    2390:	db 0b       	sbc	r29, r27
    2392:	0f b6       	in	r0, 0x3f	; 63
    2394:	f8 94       	cli
    2396:	de bf       	out	0x3e, r29	; 62
    2398:	0f be       	out	0x3f, r0	; 63
    239a:	cd bf       	out	0x3d, r28	; 61
    239c:	09 94       	ijmp

0000239e <__epilogue_restores__>:
    239e:	2a 88       	ldd	r2, Y+18	; 0x12
    23a0:	39 88       	ldd	r3, Y+17	; 0x11
    23a2:	48 88       	ldd	r4, Y+16	; 0x10
    23a4:	5f 84       	ldd	r5, Y+15	; 0x0f
    23a6:	6e 84       	ldd	r6, Y+14	; 0x0e
    23a8:	7d 84       	ldd	r7, Y+13	; 0x0d
    23aa:	8c 84       	ldd	r8, Y+12	; 0x0c
    23ac:	9b 84       	ldd	r9, Y+11	; 0x0b
    23ae:	aa 84       	ldd	r10, Y+10	; 0x0a
    23b0:	b9 84       	ldd	r11, Y+9	; 0x09
    23b2:	c8 84       	ldd	r12, Y+8	; 0x08
    23b4:	df 80       	ldd	r13, Y+7	; 0x07
    23b6:	ee 80       	ldd	r14, Y+6	; 0x06
    23b8:	fd 80       	ldd	r15, Y+5	; 0x05
    23ba:	0c 81       	ldd	r16, Y+4	; 0x04
    23bc:	1b 81       	ldd	r17, Y+3	; 0x03
    23be:	aa 81       	ldd	r26, Y+2	; 0x02
    23c0:	b9 81       	ldd	r27, Y+1	; 0x01
    23c2:	ce 0f       	add	r28, r30
    23c4:	d1 1d       	adc	r29, r1
    23c6:	0f b6       	in	r0, 0x3f	; 63
    23c8:	f8 94       	cli
    23ca:	de bf       	out	0x3e, r29	; 62
    23cc:	0f be       	out	0x3f, r0	; 63
    23ce:	cd bf       	out	0x3d, r28	; 61
    23d0:	ed 01       	movw	r28, r26
    23d2:	08 95       	ret

000023d4 <_exit>:
    23d4:	f8 94       	cli

000023d6 <__stop_program>:
    23d6:	ff cf       	rjmp	.-2      	; 0x23d6 <__stop_program>
